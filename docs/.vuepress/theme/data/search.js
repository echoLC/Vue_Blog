export default [
  {
    "title": "状态模式",
    "path": "/posts/design-pattern/state-pattern.html",
    "strippedContent": "### 定义 **允许一个对象在其内部状态改变时来改变它的行为**，对象看起来似乎修改了它的类。在状态模式中，我们把状态封装成独立的类，并将请求委托给当前的状态对象，所以当对象内部的状态改变时，对象会有不同的行为。状态模式的关键就是区分对象的内部状态。  ### 电灯程序 #### 先实现一个不用状态模式的电灯程序： ```javascript class Light {   construct () {     this.state = 'off'     this.button = null   }    // 创建一个button负责控制电灯的开关   init () {     const button = document.createElement('button')     this.button = document.body.appendChild(button)     this.button.innerHTML = '开关'      this.button.onclick = () => {       this.buttonWasPressed()     }   }    buttonWasPressed () {     if (this.state === 'off') {       console.log('开灯')       this.state = 'on'     } else if (this.state === 'on') {       console.log('关灯')       this.state = 'off'     }   } }  const light = new Light() light.init() ``` 上面代码实现了一个强壮的状态机，看起来这段代码设计得无懈可击了，这个程序没有任何Bug。 <br> <br> 比较可惜的是，世界上的电灯并非都只有开关两种状态，一些酒店里的电灯只有一个开关，但是它的表现是：第一次按下打开弱光，第二次按下打开强光，第三次才是关闭电灯。于是，我们需要修改前面的代码： ```javascript buttonWasPressed () {     if (this.state === 'off') {       console.log('弱光')       this.state = 'weakLight'     } else if (this.state === 'weakLight') {       console.log('强光')       this.state = 'strongLight'     } else if (this.state === 'strongLight') {       console.log('关灯')       this.state = 'off'   } ``` 现在我们来总结下上面的程序的缺点： - 首先，buttonWasPressed方法违反开放-封闭原则，每次新增或者修改light的状态就需要修改该方法中的代码。 - 所有跟状态相关的代码都封装在buttonWasPressed方法，导致这个方法会因为持续的加需求而膨胀到难以维护的地步。特别是在实际的开发中，每个状态可能要处理的逻辑比例子中的多很多。 - 状态切换不明显，仅仅只是一句this.state = 'off'的赋值，这样的代码很容易被遗漏掉，要想了解电灯的所有状态，我们必须深入到代码内部，耐心读完buttonWasPressed方法。 - 状态之间切换，是通过if-else语句来实现，增加或者修改一个状态可能需要改变若干个操作，这将使得buttonWasPressed方法更加难以维护。    #### 使用状态模式来改进电灯程序 首先我们先确定电灯的状态种类，然后把它们封装成单独的类，封装一般是封装对象的行为，而不是对象的状态。但是在状态模式中，关键的就是把每种状态封装成单独的类，跟状态相关的行为都封装在类的内部。从之前的代码得知，电灯有三种状态： OffLightState、WeakLightState、StrongLightState。首先编写状态类： ```javascript class OffLightState {   construct (light) {     this.light = light   }    buttonWasPressed () {     console.log('弱光')     this.light.setState(this.light.weakLightState)   } }  class WeakLightState {   construct (light) {     this.light = light   }    buttonWasPressed () {     console.log('强光')     this.light.setState(this.light.strongLightState)   } }  class StrongLightState {   construct (light) {     this.light = light   }    buttonWasPressed () {     console.log('关灯')     this.light.setState(this.light.offLightState)   } } ``` 接下来编写Light类，我们不再需要一个字符串来记录当前的状态，而是使用更加立体化的状态对象，在初始化Light类的时候就为每一个state类创建一个状态对象： ```javascript class Light {   construct () {     this.offLightState = new OffLightState(this)     this.weakLightState = new WeakLightState(this)     this.strongLightState = new StrongLightState(this)      this.currentState = this.offLightState // 初始化电灯状态     this.button = null   }    init () {     const button = document.createElement('button')     this.button = document.body.appendChild(button)     this.button.innerHTML = '开关'      this.button.onclick = () => {       this.currentState.buttonWasPressed()     }   }    setState (newState) {     this.currentState = newState   } }  const light = new Light() light.init() ``` 通过使用状态模式重构之后，我们看到程序有很多优点： - 每种状态和它对应的行为之间的关系局部化，这些行为被分散在各个对象的状态类之中，便于阅读和管理。 - 状态之间的切换逻辑分布在状态类内部，这使得我们无需编写if-else语句来控制状态直接的切换。 - 当我们需要为Light类增加一种新的状态时，只需要增加一个新的状态类，再稍微改变一下现有的代码。    ### 缺少抽象类的变通方式 在状态模式中，Light类被称为上下文（Context）。Context持有所有状态对象的引用 ，以便把请求委托给状态对象。在上面的例子中，请求最后委托到的是状态类的buttonWasPressed方法，所以所有的状态类都必须实现buttonWasPressed方法。 <br> <br> 在Java中，所有的状态类必须继承自一个State抽象类，从而保证所有的状态子类都实现buttonWasPressed方法。遗憾的是，在JavaScript中没有抽象类，也没有接口的概念。我们可以编写一个状态类，然后实现buttonWasPressed方法，在函数体中抛出错误，如果继承它的子类没有实现buttonWasPressed方法就会在状态切换时抛出异常，这样至少在程序运行期间就可以发现错误，下面优化上面的代码： ```javascript class State {   buttonWasPressed () {     throw new Error('父类的buttonWasPressed必须被重写')   } }  class OffLightState extend State {   construct (light) {     this.light = light   }    buttonWasPressed () {     console.log('弱光')     this.light.setState(this.light.weakLightState)   } } ```  ### 状态模式中的性能优化点 在上面的例子，从性能方面考虑，还有一些可以优化的点： - 有两种方式可以选择来管理state对象的创建和销毁。第一种是当state对象被需要的时候才创建并随后销毁；另一种是一开始就创建好所有的状态对象，并且始终不销毁它们。如果state对象比较大，可以用第一种方式来节省内存。如果状态改变很频繁，则最好是将state对象都创建出来，也没有必要销毁它们。 - 我们为每个Context对象都创建了一组state对象，实际上这些state对象之间是可以共享的，各个Context对象可以共享一个state对象，这也是享元模式的应用场景之一。  ### 状态模式 VS 策略模式 状态模式和策略模式像一对双胞胎，它们都封装了一系列的算法或者行为，他们的类图看起来几乎一模一样，但是从意图上看它们有很大不同。 <br> <br> 它们的相同点是，**都有一个上下文、一些策略类或者状态类，上下文把请求委托给这些类来执行**。它们之间的区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何关系，所以客户必须熟知这些策略类的作用，以便客户自己可以随时主动切换算法。但是在状态模式中，状态和状态对应的行为早已被封装好，状态之间的切换也早就被规定，“改变行为”这件事发生在状态模式的内部，对于客户来说，不需要了解这些细节。  ### JavaScript版本的状态机 上面我们使用的是传统的面向对象的方式实现状态模式，在JavaScript中，没有规定状态对象一定要从类中创建而来。另外，JavaScript可以非常方便利用委托技术，不需要事先让一个对象持有另一个对象，我们可以通过**Function.prototype.call**方法直接把请求委托给某个对象字面来执行。下面看下实现的代码： ```javascript var FSM = {   off: {     buttonWasPressed: function () {       console.log('关灯')       this.currentState = FSM.on     }   },     on: {     buttonWasPressed: function () {       console.log('开灯')       this.currentState = FSM.off     }   } }  var Light = function () {   this.currentState = FSM.off // 设置初始状态   this.button = null }  Light.prototype.init = function () {   var self = this    var button = document.createElement('button')   this.button = document.body.appendChild(button)   this.button.innerHTML = '开关'    this.button.onclick = function () {     self.currentState.buttonWasPressed.call(self)  // 把请求委托给状态机FSM   } }  const light = new Light() light.init() ``` 我们还可以使用**闭包**来编写这个例子，我们需要实现一个delegate函数： ```javascript var delegate = function (client, delegation) {   return {     buttonWasPressed: function () {  // 将客户的请求委托给delegation对象       return delegation.buttonWasPressed.apply(client, arguments)     }   } }  var FSM = {   off: {     buttonWasPressed: function () {       console.log('关灯')       this.currentState = FSM.on     }   },     on: {     buttonWasPressed: function () {       console.log('开灯')       this.currentState = FSM.off     }   } }  var Light = function () {   this.offState = delegate(this, FSM.off)   this.onState = delegate(this, FSM.on)   this.currentState = this.offState // 设置初始状态   this.button = null }  Light.prototype.init = function () {   var self = this    var button = document.createElement('button')   this.button = document.body.appendChild(button)   this.button.innerHTML = '开关'    this.button.onclick = function () {     self.currentState.buttonWasPressed()   } } ```  ### 总结 在文章中，我们通过各种方式来实现状态模式，并且对比了使用状态模式前后程序的优缺点，从中我们也可以得出状态模式的优点和缺点。它的优点如下： - 状态模式定义了状态和行为之间的关系，并它们封装在一个类里，使得添加新的状态和状态间的切换更容易。 - 避免了Context无限膨胀，状态切换的逻辑分布在状态类中，也避免了大量的if-else语句。 - 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。 - Context中的请求动作和状态类中封装的行为相互独立切互不影响，也使得修改更加容易。    状态模式的缺点：第一，我们需要在系统中定义许多状态类，编写很多的状态类是一项枯燥泛味的工作，这样也会导致系统中增加很多对象。第二，因为逻辑分散中状态类中，虽然避开了不受欢迎的条件语句，但也造成了逻辑分散的问题，我们无法在一个地方就看清整个状态机的逻辑。  "
  },
  {
    "title": "装饰者模式",
    "path": "/posts/design-pattern/decorator-pattern.html",
    "strippedContent": "### 定义 装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响这个类中派生的其他对象。装饰模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责，跟继承相比，装饰者更加轻便灵活。  ### 使用面向对象实现装饰者模式 假设我们编写一个飞机大战的游戏，飞机会根据经验值的增加升级子弹的类型，一开始飞机只能发射普通子弹，升到二级可以发射导弹，升到三级可以发射原子弹。用代码实现如下： ```javascript var Plane = function () {}  Plane.prototype.fire = function () {   console.log('发射子弹') }  var MissleDecorator = function (plane) {   this.plane = plane }  MissleDecorator.prototype.fire = function () {   this.plane.fire()   console.log('发射导弹') }  var AtomDecorator = function (plane) {   this.plane = plane }  AtomDecorator.prototype.fire = function () {   this.plane.fire()   console.log('发射原子弹') }  // 应用 let plane = new Plane() plane = new MissleDecorator(plane) plane = new AtomDecorator(plane) plane.fire() // 发送普通子弹、发送导弹、发送原子弹 ``` 导弹和原子弹装饰类的构造函数都接受plane对象，并且保存这个参数，在它们的fire方法中，除了自身的操作，还要调用plane对象的fire方法。这种方式没有改变plane对象的自身，而是将对象传递给另一个对象，这些对象以一条链的方式进行引用，形成聚合对象。 <br> 可以看到装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰对象也不需要知道它曾经被装饰过，这种透明性使得我们可以嵌套任意多个装饰对象。  ### JavaScript中的装饰者 JavaScript语言的动态性使得改变对象很容易，我们可以直接改写对象或者某个对象的方法，并不需要用“类”来装饰，使用JavaScript实现上面例子的代码如下： ```javascript const plane = {   fire () {     console.log('发射子弹')   } }  const missleDecorator = function () {   console.log('发射导弹') }  const atomDecorator = function () {   console.log('发射原子弹') }  const copyFire1 = plane.fire plane.fire = function () {   copyFire1()   missleDecorator() }  const copyFir2 = plane.fire plane.fire = function () {   copyFire2()   atomDecorator() }  plane.fire() // 发送普通子弹、发送导弹、发送原子弹 ```  ### 装饰函数 在JavaScript中，几乎一切都是对象，函数又被称为一等对象。在JavaScript中可以很方便地修改对象的属性和方法，所以要为函数添加功能，最简单粗暴的方式是直接改写函数，但是这违反开放-封闭原则。比如下面的例子： ```javascript var a = function () {   console.log(1) } // 改成 var a = function () {   console.log(1)   console.log(2) } ``` 但是如果某个函数很复杂，而且之前可能也不是你维护，随便修改很可能产生难以预料的Bug，于是我们从装饰者模式中找到了一种答案，保存原函数的引用，然后添加新的功能： ```javascript var a = function () {   console.log(1) }  var _a = a  a = function () {   _a()   console.log(2) } ``` 在实际开发中，这也是一种常见的做法。比如我们想给window绑定onload事件，但是不确定这个事件是不是被其他人绑定过，于是为了之前的函数不被覆盖，有如下代码： ```javascript window.onload = function () {   console.log(1) }  var _onload = window.onload || function () {} window.onload = function () {   _onload()   console.log(2) } ``` 这样的代码是符合开放-封闭原则的，我们增加新的功能的时候，没有修改原来的代码。但这种方式有一些缺点： - 必须维护_onload这个中间变量，如果函数的装饰链较长，或者装饰的函数变多，这些中间变量的数量也会越来越多。 - 还会有this被劫持的问题，在上面的例子中没有问题，因为调用普通函数_onload，this也指向window，现在把window.onload改成document.getElementById，代码如下： ```javascript var _getElementById = document.getElementById  document.getElementById = function (id) {   console.log(1)   return _getElementById(id) }  var button = document.getElementById('button') ``` 执行这段代码，控制台在打印1后，抛出如下异常: ```javascript // Uncaught TypeError: Illegal invocation ``` 异常的原因就是此时_getElementById是一个全局函数，调用全局函数时，this指向window的，而document.getElementById内部this预期的指向是document。所以我们需要改进代码: ```javascript var _getElementById = document.getElementById  document.getElementById = function (id) {   console.log(1)   return _getElementById.call(document, id) }  var button = document.getElementById('button') ```  ### 使用AOP装饰函数 首先定义两个函数Function.prototype.before和Function.prototype.after： ```javascript Function.prototype.before = function (beforeFn) {   var self = this    return function () {     beforeFn.apply(this, arguments)      return self.apply(this, arguments)   } }  Function.prototype.after = function (afterFn) {   var self = this    return function () {     const ret = self.apply(this, arguments)     afterFn.apply(this, arguments)      return ret   } } ``` Function.prototype.before接受一个函数作为参数，这个函数即为要添加的装饰函数，它里面有需要添加的新功能的代码。 <br> 接着把当前的this保存起来，这个this指向原函数，返回一个代理函数。这个代理函数的作用是把请求分别转发给新添加的函数和原函数，并且保证它们的执行顺序，让新添加的函数在原函数之前执行，也叫前置装饰，这样就实现了动态装饰的效果。 <br> 因为我们在函数中保存了this，通过apply函数绑定正确的this，保证函数在被装饰之后，this不会被劫持。于是前面的例子，我们可以这样写： ```javascript  document.getElementById = document.getElementById.before(function () {    console.log(1)  })   console.log(document.getElementById('button')) ```  ### AOP应用 #### 1.数据统计上报 分离业务代码和数据统计代码，无论在什么语言中，都是AOP的经典应用之一。在项目的开发结尾的时候，我们一般需要加一些统计数据的代码，这些过程可能让我们被迫改动已经封装好的函数。比如，页面中有登录按钮，点击登录按钮，弹出登录弹窗的同时还要上报数据，来统计有多少用户点击了登录按钮。下面简单的代码实现： ```javascript function showLoginModal () {   console.log('打开登录弹窗')   log('传入一些按钮信息') }  function log (info) {   console.log('上报用户信息和按钮信息到服务器') }  document.getElementById('loginBtn').onclick = showLoginModal ``` 可以看到，在showLogin函数里，既要负责打开弹窗的功能，又要负责数据上报，这两个不同层面的代码耦合在一起，我们可以使用AOP进行优化： ```javascript var showLoginModal = function () {   console.log('打开登录弹窗')   log('传入一些按钮信息') }  function log (info) {   console.log('上报用户信息和按钮信息到服务器') }  showLoginModal = showLoginModal.after(log)  // 打开弹窗之后上报数据  document.getElementById('loginBtn').onclick = showLoginModal ```  #### 使用AOP动态改变函数的参数 观察Function.prototype.before函数： ```javascript Function.prototype.before = function (beforeFn) {   var self = this    return function () {     beforeFn.apply(this, arguments)      return self.apply(this, arguments)   } } ``` 可以看到beforeFn函数和原函数共用参数arguments，所以我们在beforeFn中修改参数后，原函数接收的参数也会发生变化。 <br> 现在有一个用于ajax请求的函数，它负责项目中所有的ajax异步请求： ```javascript var ajax = function (type, url, param) {   console.dir(param)    // 这里是发送请求的代码 }  ajax('get', 'http://xxx.com/userInfo', { name: 'uzi' }) ``` 上面代码表示向服务端发起一个获取用户信息的请求，传递的参数是{ name: 'uzi' }。ajax函数在项目中一直工作良好，突然有有一天，网站遭受了CSRF攻击，解决CSRF的一个办法就是在所有HTTP请求中带上一个token参数。于是我们定义了一个生成token的函数： ```javascript var getToken = function () {   return 'token' } ``` 下面给所有请求加上token参数： ```javascript var ajax = function (type, url, param) {   param = param || {}   param.token = getToken()    // 这里是发送请求的代码 } ``` 这样问题就解决了，但是ajax函却变得僵硬了，虽然每个ajax请求都自动带上了token参数，在当前项目是没有什么问题。但是，如果将来要将这个ajax函数封装到公司的通用库里，那这个token参数可能就是多余的了，也许另一个项目不需要token参数，或者生成token的算法不一样，无论怎么样，都需要修改这个ajax函数。我们用AOP来解决这个问题： ```javascript var ajax = function (type, url, param) {   console.dir(param)    // 这里是发送请求的代码 }  var getToken = function () {   return 'token' }  // 使用Function.prototype.before装饰ajax函数 ajax = ajax.before(function (type, url, param) {   param.token = getToken() })  ajax('get', 'http://xxx.com/userInfo', { name: 'uzi' })  // { name: 'uzi', token: 'token'} ``` 这样我们就保证了ajax函数的干净，提高了ajax函数的复用性，并且也满足了添加token的需求。  #### 插件式的表单验证 表单验证在web开发中是一个很常见的需求，比如在一个登录页面，我们在把用户的数据，比如用户名、密码等信息提交给服务器之前，就会经常需要做校验，假设我们现在只需要校验字段是否为空，于是有如下代码： ```javascript var username = document.getElementById('username') var password = document.getElementById('password') var submitBtn = document.getElementById('submitBtn')  function submitHandler () {   if (username.value === '') {     return alert('用户名不能为空')   }   if (password.value === '') {     return alert('密码不能为空')   }   ajax('post', 'http://xxx.com/login', { username: username.value, password: password.value }) }  submitBtn.onclick = submitHandler ``` 上面的submitHandler在此处承担了两个职责，除了ajax的请求之外，还要验证用户输入的合法性，这种函数首先一旦校验的字段很多，代码就会臃肿，而且函数职责也很混乱，无法复用。 下面使用AOP进行优化，首先分离校验相关的代码: ```javascript function validateField () {    if (username.value === '') {     alert('用户名不能为空')     return false   }   if (password.value === '') {     alert('密码不能为空')     return false   } }  function submitHandler () {   var params = { username: username.value, password: password.value }   ajax('post', 'http://xxx.com/login', params) } ``` 改写前面的Function.prototype.before: ```javascript Function.prototype.before = function (beforeFn) {   var self = this    return function () {     const ret = beforeFn.apply(this, arguments)     if (ret === false) {       return     }      return self.apply(this, arguments)   } } ``` 再用validateField前置装饰submitHandler: ```javascript submitHandler = submitHandler.before(validateField)  submitBtn.onclick = submitHandler ``` 这样我们就完美将校验的代码和提交ajax请求的代码完全分离开来，它们不再有耦合关系，这样我们在项目中可以把一些校验函数封装起来，达到复用的目的。  ### 装饰者模式和代理模式 装饰者模式和代理模式的结构看起来很像，这两种模式都描述了怎么样为对象提供一定程度上的间接引用，它们的实现部分保留了对另一个对象的引用，并且客户是直接向那个对象发送请求。 <br> <br> 代码模式和装饰者模式最重要的区别是在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便时或者不合符需求时，为本体提供一个替代者。本体定义了核心的功能，而代理提供的作用一个是直接拒绝一些访问，另一个就是在本体之前做一些额外的事情。而装饰者的作用是给对象动态添加行为，可以说代理模式强调一种本体和代替者的一种可以静态表达的关系，这种关系在一开始就基本被确定了。而装饰者模式一开始并不能确定所有的功能，在不同的场景中，可能会根据需要添加不同的装饰者，这些装饰者可以形成一条长长的装饰链。  ### 总结 通过上面的三个应场景：数据上报、动态改变函数参数以及表单校验，我们可以看到在JavaScript中，我们了解了装饰函数，了解了AOP，他们就是JavaScript中独特的装饰者模式，这种模式在实际开发中非常有用。"
  },
  {
    "title": "策略模式",
    "path": "/posts/design-pattern/strategy-pattern.html",
    "strippedContent": "### 定义 定义一系列算法，把它们一个个封装成策略类，具体的算法封装在策略类的内部方法里，并且使这些策略类可以互相替换。一个基于策略模式的设计至少由两部分组成，第一部分是一组策略类，每个策略类里封装了具体的算法。第二部分是环境类Context，Context主要接受客户的请求，然后把请求委托给某一个策略类。  ### 应用 下面主要通过两个具体的案例来介绍策略类的使用。 #### 使用策略模式计算奖金 很多公司都设有年终奖，而且年终奖一般跟员工的月工资基数和绩效有关。如果绩效为S，发4个月年终奖；绩效A发3个月；绩效为B，发2个月。用代码计算奖金如下： ```javascript const calculateBonus = function (performanceLevel, salary) {   if (performanceLevel === 'S') {     return salary * 4   }   if (performanceLevel === 'A') {     return salary * 3   }   if (performanceLevel === 'B') {     return salary * 2   } } ``` 用简单的代码配合if语句就能实现该功能，但是却有很多的缺点。 * calculateBonus函数庞大，有很多的if语句。 * calculateBonus缺乏弹性，如果再增加一种新的绩效等级C，或者修改其中的一种绩效的计算方式，则必须深入calculateBonus的内部实现，违法了开闭原则。 * 复用性差，如果其它地方需要重用到这些计算奖金的算法，只能通过复制和粘贴 <br>  下面使用策略模式重构代码。第一步，定义策略类： ```javascript // S class PerformanceS {   constructor (salary) {     this.salary = salary   }    calculate () {     return this.salary * 4   } }  // A class PerformanceA {   constructor (salary) {     this.salary = salary   }    calculate () {     return this.salary * 3   } }  // B class PerformanceB {   constructor (salary) {     this.salary = salary   }    calculate () {     return this.salary * 2   } } ``` 第二步，定义环境类，Bonus： ```javascript class Bonus {   constructor (salary) {     this.salary = salary   }    setStrategy (Strategy) {     this.strategy = new Strategy(this.salary)   }    getBonus () {     return this.strategy.calculate()   } } ``` 使用： ```javascript const bonus = new Bonus(7000) bonus.setStrategy(PerformanceS) bonus.getBonus() // 28000 ``` 重构完之后，我们发现代码更加清晰，每个类的职责也更加鲜明。  #### JavaScript版本的设计模式 上面我们是用面向对象的方式来实现策略模式，在JavaScript中，函数也是对象，所以更加直接的做法是： ```javascript const strategies = {   'S': function (salary) {     return salary * 4   },   'A': function (salary) {     return salary * 3   },   'B': function (salary) {     return salary * 2   } }  const calculateBonus = function (performanceLevel, salary) {   return strategies[performanceLevel](salary) } ```  #### 表单校验 策略模式中的策略类主要是用来封装算法的，但是如果只封装算法，有点大材小用。在实际开发中，我们可以把算法定义变得更广，比如一系列的业务规则，这些业务规则的目标一致，并且可以被相互替换使用。下面通过策略模式来编写一个表单校验的例子。 <br> <br> 需求是这样的，我们在编写一个注册的页面，在点击注册按钮之前，有如下几条校验规则： * 用户名长度不能为空。 * 密码长度不能少于6位。 * 手机号必须符合格式。    **第一个版本** ```javascript const registerForm = document.getElementById('registerForm')  registerForm.onsubmit = function () {   if (registerForm.userName.value === '') {     alert('用户名不能为空')     return   }   if (registerForm.password.value.length < 6) {     alert('用户密码不能少于6位')     return   }   if (!/(^1[3|5|7|8][0-9]{9}$)/.test(registerForm.phone.value)) {     alert('用户手机格式不正确')     return   } } ``` 它的缺点跟计算奖金的第一个版本差不多，缺乏弹性，违反开闭原则，复用性差。 <br> <br> **用策略模式重构** <br> 定义校验规则的策略： ```javascript const strategies= {   isNonEmpty (value, errMsg) {     if (value === '') {       return errMsg     }   },   minLength (value, length, errMsg) {     if (value.length < length) {       return errMsg     }   },   isMobile (value, errMsg) {     if (!/(^1[3|5|7|8][0-9]{9}$)/.test(value)) {       return errMsg     }   } } ``` 先看具体怎么使用Validator： ```javascript const validatorFunc = function () {   const validator = new Validator()   // 添加校验规则   validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空')   validator.add(registerForm.password, 'minLength:6', '用户密码不能少于6位')   validator.add(registerForm.mobile, 'isMobile', '用户手机格式不正确')    const errMsg = validator.start()  // 获得校验结果   return erMsg }  const registerForm = document.getElementById('registerForm') registerForm.onsubmit = function () {   const errMsg = validatorFunc()    if (errMsg) {     alert(errMsg)     return   } } ``` 定义环境类Validator类: ```javascript class Validator {   static rules = []      add (dom, rule, errMsg) {     const ary = rule.split(':')     this.rules.push(function () {       const rule = ary.shift()       ary.unshift(dom.value)       ary.push(errMsg)       return strategies[rule].apply(dom, ary)     })   }    start () {     for (let i = 0; i < this.rules.length; i++) {       const validatorFunc = this.rules[i]       const errMsg = validatorFunc()       if (errMsg) {         return errMsg       }     }   } } ``` 通过策略模式重构之后，只需要通过配置就可以完成表单的校验，这些校验规则还可以在任何地方复用。如果需要进行修改，比如改校验规则或者提示，也是成本很低的。  #### 策略模式的优缺点 **优点：** * 策略模式利用组合、委托和多态等技术和思想，避免多重if-else语句。 * 提供了对开发-关闭原则的完美支持，将算法封装在策略类中，易于修改，易于扩展。 * 由于策略模式是将算法封装在策略类中，所以这些算法可以在项目中的任何地方复用。 * 利用组合和委托让Context拥有执行算法的能力，也是继承的一种替代方案。 <br>  **缺点：** * 首先，使用策略模式会在程序中增加很多的策略类，增加了项目的代码。 * 其次，使用策略模式，必须了解所有的strategy类，这样才能知道使用哪个策略类。所以策略类必须向客户暴露它的所有实现，违反了最少知识原则。"
  },
  {
    "title": "享元模式",
    "path": "/posts/design-pattern/fly-weight-pattern.html",
    "strippedContent": "### 定义 享元模式是一种用于性能优化的模式，享元模式的核心是运用共享对象的技术来有效支持大量细粒度的对象。如果系统因为创建了大量对象而导致内存占用过高，享元模式就能发挥作用了。  ### 一个简单的例子 假设有个制衣工厂，目前的产品有50种男款衣服和50种女款衣服，为了推销产品，工厂决定生产一些塑料模特来穿上他们的衣服拍成广告照片，正常情况下需要50个男模特和50个女模特，用程序表达： ```javascript class Model {   constructor (sex, underwear) {     this.sex = sex     this.underwear = underwear   }    takePhoto () {     console.log(`sex ${this.sex} underwear ${this.underwear}`)   } }  for (let i = 0; i < 50; i++) {   const maleModel = new Model('male', 'underwear' + i)   maleModel.takePhoto() }  for (let j = 0; j < 50; j++) {   const femaleModel = new Model('male', 'underwear' + j)   femaleModel.takePhoto() } ``` 上述代码产生了一百个对象，如果将来有10000种的男款和10000种女款的衣服，那程序可能因为存在如此多的对象而崩溃。 <br> <br> 换种思路，上面的例子中最需要区分的是男女模特，那我们把其它参数从构造函数中移除，只接受sex参数： ```javascript class Model {   constructor (sex) {     this.sex = sex   }    takePhoto () {     console.log(`sex ${this.sex} underwear ${this.underwear}`)   } } ``` 分别创建一个男模特和一个女模特： ```javascript const maleModel = new Model('male') const femaleModel = new Model('female') ``` 给男模特依次穿上不同的衣服，并拍照： ```javascript  for (let j = 0; j < 50; j++) {   maleModel.underwear = 'underwear' + j   femaleModel.takePhoto() } ``` 女模特穿衣拍照类似，可以看到，改进代码之后，只需要两个对象便完成了同样的功能。  ### 内部状态和外部状态 上面的例子是享元模式的雏形，享元模式要求将对象的属性划分为内部状态和外部状态，状态在这里一般指的是对象的属性。在上面的例子中，内部状态就是模特的性别，外部状态对应模特会变化的不同款的衣服。那么如何划分内部状态和外部状态了？下面有几条经验可以提供一些指导。 - 内部状态存储于对象内部 - 内部状态可以被对象共享 - 内部状态通常独立于具体的场景，通常不会变 - 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享  这样的话，我们就可以把内部状态相同的对象指定为同一个共享的对象，而外部状态从对象中剥离出来，储存在外部。虽然结合外部状态组装成一个完整的对象的过程需要花费一定的时间，但是却可以大大减少系统中对象的数量，所以享元模式也是一种使用时间来换取空间的优化模式。  ### 文件上传 **对象爆炸** <br> 在一个上传模块的开发中，如果没有用享元模式优化，会出现因为对象数量爆炸而到导致内存占用过大的问题。文件上传功能虽然可以依照队列，一个一个地排队上传，但也支持同时选择2000个文件，每一个文件都对应着一个JavaScript上传对象的创建。下面先看下代码实现： ```javascript let id = 0  window.startUpload = function (uploadType, files) {   for (let i = 0, file; file=files[i++]) {     const uploadObj = new Upload(uploadType, file.fileName, file.fileSize)     uploadObj.init(id++)   } } ``` 下面实现Upload类： ```javascript class Upload {   constructor (uploadType, fileName, fileSize) {     this.uploadType = uploadType     this.fileName = fileName     this.fileSize = fileSize     this.dom = null   }    init (id) {     const self = this     this.id = id     this.dom = document.createElement('div')     this.dom.innerHTML = `<span>文件名称：${this.fileName}，文件大小：${this.fileSize}</span><button class=\"delfile\">删除</button>`      this.dom.querySelector('.delfile').onclick = function () {       self.delFile()     }     document.body.appendChild(this.dom)   }    delFile () {     if (this.fileSize < 300) {       return this.dom.parentNode.removeChild(this.dom)     }     if (window.confirm(`确定要删除文件吗？${this.fileName}`)) {       return this.dom.parentNode.removeChild(this.dom)     }   } } ``` 然后我们就可以这样使用： ```javascript startUpload('plugin', [   {     fileName: '1.txt',     fileSize: 1000   },   {     fileName: '2.txt',     fileSize: 3000   },   {     fileName: '3.html',     fileSize: 4000   } ])  startUpload('flash', [   {     fileName: '1.txt',     fileSize: 1000   },   {     fileName: '2.txt',     fileSize: 3000   },   {     fileName: '3.html',     fileSize: 4000   } ]) ``` 从上面的代码中可以看出，有多少需要上传的文件，就需要创建多少个upload对象，所以我们可以用享元模式重构它。先确认好对象的内部状态和外部状态，从上面的例子中，我们可以看出，upload必须依赖uploadType属性才能工作，因为插件上传、Flash上传、表单上传的工作原理区别很大，它们各自调用的接口也不一样，所以在创建upload对象时，必须明确到底使用哪种上传类型。下面看具体实现代码。 <br> **剥离外部状态** <br> ```javascript class Upload {   constructor (uploadType) {     this.uploadType = uploadType   }    delFile (id) {     uploadManager.setExternalState(id, this)      if (this.fileSize < 300) {       return this.dom.parentNode.removeChild(this.dom)     }     if (window.confirm(`确定要删除文件吗？${this.fileName}`)) {       return this.dom.parentNode.removeChild(this.dom)     }   } } ``` **工厂进行上传对象实例化** <br> ```javascript const UploadFactory = (function () {   const createdFlyWeightObjects = {}   return {     create (uploadType) {       if (createdFlyWeightObjects[uploadType]) {         return createdFlyWeightObjects[uploadType]       }       return createdFlyWeightObjects[uploadType] = new Upload(uploadType)     }   } })() ``` **管理封装外部状态** <br> ```javascript const uploadManager = (function () {   const uploadDatabase = {}    return {     add (id, uploadType, fileName, fileSize) {       const flyWeightObj = UploadFactory.create(uploadType)      const dom = document.createElement('div')     dom.innerHTML = `<span>文件名称：${fileName}，文件大小：${fileSize}</span><button class=\"delfile\">删除</button>`      dom.querySelector('.delfile').onclick = function () {       flyWeightObj.delFile(id)     }      document.body.appendChild(dom)      uploadDatabase[id] = {       fileName,       fileSize,       dom     }      return flyWeightObj     },     setExternalState (id, flyWeightObj) {       const uploadData = uploadDatabase[id]       for (const key in uploadData) {         flyWeightObj[key] = uploadData[key]       }     }   } })() ``` 最后改写startUpload函数： ```javascript let id = 0  window.startUpload = function (uploadType. files) {   for (let i = 0, file; file = files[i++]) {     const uploadObj = uploadManager.add(++id, uploadType, file.fileName, file.fileSize)   } } ``` 最后测试使用： ```javascript startUpload('plugin', [   {     fileName: '1.txt',     fileSize: 1000   },   {     fileName: '2.txt',     fileSize: 3000   },   {     fileName: '3.html',     fileSize: 4000   } ])  startUpload('flash', [   {     fileName: '1.txt',     fileSize: 1000   },   {     fileName: '2.txt',     fileSize: 3000   },   {     fileName: '3.html',     fileSize: 4000   } ]) ``` 使用享元模式重构之前，一共创建了6个upload对象，而重构之后，对象的数量减少为2，而且就算上传的文件有2000个，upload对象数量依旧是2。  ### 对象池 对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接创建，而是从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取的对象完成它的职责之后，再进入池子等待下次获取。对象池的应用广泛，HTTP连接池和数据库连接池都是代表应用，在Web前端开发中，对象池使用的场景大多是跟DOM相关，因为创建DOM和操作DOM既耗费空间也耗费时间。 <br> <br> **地图小气泡对象池** <br> 假设我们开发一个地图应用，地图上经常会出现一些标志地面建筑的小气泡，我们称呼为tooltip。假设我们在搜附近的网吧时地图上出现了两个小气泡，然再搜附近的便利店，页面上出现了6个气泡。使用对象池实现的思想，第一次搜创建的2个气泡不会被删除，而是它们放在对象池中，在第二次搜索的时候，就可以复用前面2个，只需要再创建4个气泡。下面看代码实现： ```javascript const tooltipFactory = (function () {   const tooltipPool = []    return {     create () {       // 对象池为空则创建       if (tooltipPool.length === 0) {         const div = document.createElement('div')         document.body.appendChild(div)         return div       } else {         return tooltipPool.shift()  // 从对象池里取出一个       }     },     recover (tooltip) {       return tooltipPool.push(tooltip)     }     } })() ``` 第一次搜索的时候，创建两个tooltip，创建ary数组保存tooltip，方便下次搜索绘制前回收: ```javascript let ary = [] const tooltips = ['A', 'B'] for (let i = 0, len = tooltips.length; i < len; i++) {   const tooltip = tooltipFactory.create()   tooltip.innerHTML = tooltips[i]   ary.push(tooltip)  } ``` 第二次搜索绘制前，先回收前面两个tooltip: ```javascript for (let i = 0, len = ary.length; i < len; i++) {   tooltipFactory.recover(ary[i]) } ``` 再创建6个气泡： ```javascript const tooltips = ['A', 'B', 'C', 'D', 'E', 'F'] for (let i = 0, len = tooltips.length; i < len; i++) {   const tooltip = tooltipFactory.create()   tooltip.innerHTML = tooltips[i] } ``` 对象池跟享元模式思想有点相似，虽然innerHTML的值也可以看作tooltip的外部状态，但在这里我们并没有主动分离内部状态和外部状态。 <br> <br> **通用对象池的实现** ```javascript const objectPollFactory = function (createObjFn) {   const objectPool = []    return {     create () {       // 对象池为空则创建       const obj = objectPool.length === 0 ?        createObjFn.apply(this, arguments) : objectPool.shift()              return obj     },     recover (obj) {       return objectPool.push(obj)     }     } } ``` 对象池是另一种性能优化方案，它跟享元模式有点类似，但没有分离内部状态和外部状态这个过程。  ### 总结 享元模式是一种很好的性能优化方案，但也会带来一些复杂性的问题，从文件上传的例子我们可以看出，使用了享元模式，我们需要多维护一个factory对象和一个manager对象，在不使用享元模式的环境下，这些开销是可以避免的。享元模式带来的好处很大程度取决于如何使用以及何时使用，当你的项目出现以下情况比较适合使用享元模式： - 一个程序中使用了大量的相似对象 - 使用了大量对象后，造成很大的内存开销 - 对象的大多数状态可以变为外部状态 - 剥离出对象的外部状态后，可以用相对较少的共享对象取代大量对象  使用享元模式的关键是把内部状态和外部状态分离开来，有多少种内部状态的组合，系统中并最多存在多少个共享对象。"
  },
  {
    "title": "职责链模式",
    "path": "/posts/design-pattern/chain-of-responsibility.html",
    "strippedContent": "### 定义 职责链模式的定义：使多个对象都有机会处理请求，从而避免了请求的发送者与多个接收者直接的耦合关系，将这些接收者连接成一条链，顺着这条链传递该请求，直到找到能处理该请求的对象。  ### 应用 假设我们负责一个售卖手机的网站，需求的定义是：经过分别缴纳500元定金和200元定金的两轮预订，现在到了正式购买阶段。公司对于交了定金的用户有一定的优惠政策，规则如下：缴纳500元定金的用户可以收到100元优惠券；纳200元定金的用户可以收到50元优惠券；而没有缴纳定金的用户进入普通购买模式，没有优惠券，而且在库存不足的情况下，不一定能保证买得到。下面开始设计几个字段，解释它们的含义： - orderType：表示订单类型，值为1表示500元定金用户，值为2表示200元定金用户，值为3表示普通用户。 - pay：表示用户是否支付定金，值为布尔值true和false，就算用户下了500元定金的订单，但是如果没有支付定金，那也会降级为普通用户购买模式。 - stock：表示当前用户普通购买的手机库存数量，已经支付过定金的用户不受限制。  下面把上面的需求用代码实现： ```javascript const order = function (orderType, pay, stock) {   if (orderType === 1) {     if (pay === true) {       console.log('500元定金预购，得到100元优惠券')     } else {       if (stock > 0) {         console.log('普通用户购买，无优惠券')       } else {         console.log('手机库存不足')       }     } else if (orderType === 2) {       if (pay === true) {         console.log('200元定金预购，得到50元优惠券')       } else {         if (stock > 0) {           console.log('普通用户购买，无优惠券')         } else {           console.log('手机库存不足')         }       }     } else if (orderType === 3) {       if (stock > 0) {           console.log('普通用户购买，无优惠券')         } else {           console.log('手机库存不足')       }    } }  order(1, true, 500)  // 输出：500元定金预购，得到100元优惠券' ``` 虽然通过上面代码我们得到了想要的结果，但是代码难以阅读，维护起来也很困难，如果需要修改需求，那代价无疑是巨大的。 <br> <br> **使用职责链模式重构** <br> 下面我们使用职责链模式重构，先把500元订单、200元订单以及普通购买拆分成三个函数。代码如下： ```javascript function order500 (orderType, pay, stock) {   if (orderType === 1 && pay === true) {     console.log('500元定金预购，得到100元优惠券')   } else {     order200(orderType, pay, stock)   } }  function order200 (orderType, pay, stock) {   if (orderType === 2 && pay === true) {     console.log('200元定金预购，得到50元优惠券')   } else {     order200(orderType, pay, stock)   } }  function orderNormal (orderType, pay, stock) {   if (stock > 0) {     console.log('普通用户购买，无优惠券')   } else {     console.log('手机库存不足')   } }  // 测试 order500(1, true, 500)  // 500元定金预购，得到100元优惠券 order500(1, false, 500)  // 普通用户购买，无优惠券 order500(2, true, 500)  // 200元定金预购，得到50元优惠券 order500(3, false, 500)  // 普通用户购买，无优惠券 order500(3, false, 0)   // 手机库存不足 ``` 可以看到，重构后的代码已经清晰很多，减少了大量的if-else嵌套，每个函数的职责分明。但是还不够，虽然我们把大函数拆分成了三个小函数，但是请求在链条中传递的顺序很僵硬，传递请求的代码跟业务代码耦合在一起，如果有一天要增加300元定金的预订，那么就要切断之前的链条，修改订单500函数的代码，重新在500和200之间加一根新的链条，这违反了开放-封闭原则。 <br> <br> **灵活可拆分的职责链节点** <br> 首先修改三个函数，如果某个节点不能处理请求，则返回一个特定的字符串“nextSuccessor”来表示请求需要继续往后传递： ```javascript function order500 (orderType, pay, stock) {   if (orderType === 1 && pay === true) {     console.log('500元定金预购，得到100元优惠券')   } else {     return 'nextSuccessor'   } }  function order200 (orderType, pay, stock) {   if (orderType === 2 && pay === true) {     console.log('200元定金预购，得到50元优惠券')   } else {     return 'nextSuccessor'   } }  function orderNormal (orderType, pay, stock) {   if (stock > 0) {     console.log('普通用户购买，无优惠券')   } else {     console.log('手机库存不足')   } } ``` 接下来需要定义一个Chain类将三个函数包装进职责链节点： ```javascript class Chain {   constructor (fn) {     this.fn = fn     this.successor = null   }    setNextSuccessor (successor) {     return this.successor = successor   }    passRequest () {     const res = this.fn.apply(this, arguments)      if (res === 'nextSuccessor') {       return this.successor && this.successor.passRequest.apply(this.successor, arguments)     }     return res   } }  // 包装三个订单函数 const chainOrder500 = new Chain(order500) const chainOrder200 = new Chain(order200) const chainOrderNormal = new Chain(orderNormal)  // 指定节点在职责链中的位置 chainOrder500.setNextSuccessor(chainOrder200) chainOrder200.setNextSuccessor(chainOrderNormal)  // 最后把请求传递给第一个节点 chainOrder500.passRequest(1, true, 500)   // 500元定金预购，得到100元优惠券 chainOrder500.passRequest(2, true, 500)   // 200元定金预购，得到50元优惠券 chainOrder500.passRequest(3, true, 500)   // 普通用户购买，无优惠券 chainOrder500.passRequest(1, false, 0)    // 手机库存不足 ``` 改进之后的代码，我们可以灵活地增加、移除和修改链中的节点顺序，如果后面增加了300预定金的类型，只需要在链中增加一个节点： ```javascript function order300 () {   // 省略代码 }  const chainOrder300 = new Chain(order300) chainOrder500.setNextSuccessor(chainOrder300) chainOrder300.setNextSuccessor(chainOrder200) ``` 这样的修改简单容易，完全不用理会原来其它订单的代码。  ### 异步的职责链 在上面的例子中，每个节点函数都是同步返回一个特定值来表示是否把请求传递给下一个节点。但是在实际应用中，我们经常会遇到一些异步的问题，比如要在某个节点中通过发起一个ajax异步请求，需要根据异步请求返回的结果才决定是否继续传递请求，这时候我们需要再添加一个函数，手动传递请求给职责链中的下一个节点： ```javascript class Chain {   constructor (fn) {     this.fn = fn     this.successor = null   }    setNextSuccessor (successor) {     return this.successor = successor   }    next () {     return this.successor && this.successor.passRequest.apply(this.successor, arguments)   }    passRequest () {     const res = this.fn.apply(this, arguments)      if (res === 'nextSuccessor') {       return this.successor && this.successor.passRequest.apply(this.successor, arguments)     }     return res   } } ``` 看一个异步使用的例子： ```javascript const fn1 = new Chain(function () {   console.log(1)   return 'nextSuccessor' })  const fn1 = new Chain(function () {   console.log(2)   setTimeout(() => {     this.next()   }, 1000) })  const fn3 = new Chain(function () {   console.log(3) })  fn1.setNextSuccessor(fn2).setNextSuccessor(fn3) fn1.passRequest() ``` 这样我们得到了一个可以处理异步情况的职责链，异步的职责链加上命令模式，可以很方便地创建一个异步ajax队列库。  ### 用AOP实现职责链 前面的例子我们是利用了一个Chain类来把普通函数包装成职责链的节点，利用JavaScript函数式的特性，我们可以实现一种更加方便地方法来创建职责链： ```javascript Function.prototype.after = function (fn) {   const self = this   return function () {     const res = self.apply(this, arguments)     if (res === 'nextSuccessor') {       return fn.apply(this, arguments)     }     return res   } }  const order = order500.after(order200).after(orderNormal) order(1, true, 500)   // 500元定金预购，得到100元优惠券 order(2, true, 500)   // 200元定金预购，得到50元优惠券 order(3, true, 500)   // 普通用户购买，无优惠券 order(1, false, 0)    // 手机库存不足 ``` 使用AOP方式实现职责链简单又巧妙，但这种方式把函数叠加在一起，也增加了函数的作用域，如果链条太长，也会有一定的性能问题。  ### 总结 职责链模式的最大优点就是解耦了请求发送者和多个请求接收者之间的关系。其次，使用了职责链模式之后，链中的节点对象可以灵活地拆分重组，增加、删除和修改节点在链中的位置都是很容易地事。它还有一个优点就是，可以手动地指定起始节点，请求并不是一定要从链中的第一个节点开始传递。 <br> <br> 当然，这种模式并非没有缺点，首先我们不能保证某个请求一定会被链中的节点处理，所以需要在链尾增加一个保底的接受者处理这种情况。另外职责链模式使得程序中多了一些节点对象，可能在某一次请求传递中，大部分节点并没有起作用，所以过长的职责链会带来性能的损耗。 <br> <br> 在JavaScript中。无论是作用链、原型链，还是DOM节点中的事件冒泡，我们都能从中找到职责链的影子。"
  },
  {
    "title": "中介者模式",
    "path": "/posts/design-pattern/mediator-pattern.html",
    "strippedContent": "### 定义 中介者模式的作用就是解除对象与对象之间的紧耦合关系，所有对象通过中介者来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。 <br> <center> ![objects image](/objects.png) <br> 图一 </center> <br> <center> ![mediator image](/mediator.png) <br> 图二 </center> <br> 图一中对象之间关系复杂，是多对多的关系；使用中介者模式后，将图一中的多对多关系变成了图二的一对多的关系。  ### 应用 下面通过一个泡泡糖游戏来介绍中介者模式的应用。 <br> 在刚开始设计游戏的时候，只支持两个玩家同时进行对战。首先定义一个玩家类，它有三个方法win、lose、die，因为玩家的数目是2，所以当其中一个玩家死亡游戏并结束了，同时通知他的对手胜利。于是有下面的代码： ```javascript class Player {   constructor (name) {     this.name = name     this.enemy = null  // 敌人   }    win () {     console.log(`${this.name} won`)   }    lose () {     console.log(`${this.name} lost`)   }    die () {     this.lose()     this.enemy.win()   } }  // 创建两个玩家 const player1 = new Player('蘑菇头') const player2 = new Player('闰土')  // 给玩家互设敌人 player1.enemy = player2 player2.enemy = player1 ``` 当玩家player1死亡的时候，只需要调用die方法，并结束了这局游戏： ```javascript player1.die()  // 蘑菇头 lost，闰土 won ``` 两个玩家的游戏没什么意思，满足不了一堆玩家一起玩，于是加了需求，可以组队玩。 <br> **给游戏增加队伍** <br> 首先定义一个数组players保存所有玩家，每次创建玩家，循环players给每个玩家添加敌人或者队友，然后给玩家添加队友列表、敌人列表、队伍颜色、玩家状态，所以我们改写Player类： ```javascript let players = []  //   class Player {   constructor (name, teamColor) {     this.name = name     this.partners = []     this.enemies = []     this.state = 'live'     this.teamColor = teamColor   }    win () {     console.log(`${this.name} won`)   }    lose () {     console.log(`${this.name} lost`)   }    die () {     let all_dead = true          this.state = 'dead'  // 修改玩家的状态      for (let i = 0, partner; partner = this.partners[i++];) {       if (partner.state !== 'dead') {         all_dead = false         break       }     }      if (all_dead === true) {       this.lose()        for (let i = 0, partner; partner = this.partners[i++];) {         partner.lose()       }        for (let i = 0, enemy; enemy = this.enemies[i++];) {         enemy.win()       }     }    } } ```  最后定义工厂函数来创建玩家： ```javascript const playerFactory = function (name, teamColor) {   const newPlayer = new Player(name, teamColor)      for (let i = 0, player; player = players[i++];) {     if (player.teamColor === newPlayer.teamColor) {       player.partners.push(newPlayer)       newPlayer.partners.push(player)     } else {       player.enemies.push(newPlayer)       newPlayer.enemies.push(player)     }   }    players.push(newPlayer)   return newPlayer } ``` 创建玩家两队玩家： ```javascript const player1 = playerFactory('A', 'red') const player2 = playerFactory('B', 'red') const player3 = playerFactory('C', 'red') const player4 = playerFactory('D', 'red')  const player5 = playerFactory('E', 'blue') const player6 = playerFactory('F', 'blue') const player7 = playerFactory('G', 'blue') const player8 = playerFactory('H', 'blue') ``` 然后让红队玩家全部死亡: ```javascript player1.die()  // A lost player2.die()  // B lost player3.die()  // C lost player4.die()  // D lost， E won、 F won、 G won、 H won ``` 上面的代码虽然能完成最后我们想要的效果，但是每个玩家之间都是紧密相关的，每个玩家都会有一个partners和enemyies来保存其它玩家的引用，任何一个玩家死亡或者进行其它操作，都要显示地通知其它玩家。在上面的例子中，只有8个玩家可能还没有对你产生足够多的困扰。但是在实际应用中，每个游戏都有成千上万的玩家，几十支队伍互相厮杀，这时候玩家状态改变，如果通过循环去通知其它玩家，估计游戏随时会崩溃。 <br> **用中介者模式改造游戏** <br> 首先还是定义玩家类，只不过在玩家的类方法中，不需要负责执行具体的逻辑，而是把操作交给中介者，我们命名中介者为playDirector。看代码： ```javascript class Player {   constructor (name, teamColor) {     this.name = name     this.teamColor = teamColor     this.state = 'live'   }    win () {     console.log(`${this.name} won`)   }    lose () {     console.log(`${this.name} lost`)   }    die () {     this.state = 'dead'     playDirector.receiveMessage('playerDead', this)   }    // 移除玩家   remove () {     playDirector.receiveMessage('removePlayer', this)   }    // 玩家换队   changeTeam () {     playDirector.receiveMessage('changeTeam', this)   } } ``` 改写创建玩家的工厂函数，这个工厂只需要创建玩家，不需要给玩家设置队友和敌人： ```javascript const playerFactory = function (name, teamColor) {   const newPlayer = new Player(name, teamColor)   playDirector.receiveMessage('addPlayer', newPlayer)    return newPlayer } ``` 通过前面的代码，我们可以看出，中介者需要暴露一个receiveMessage接口，负责接收player对象发送的消息，然后中介者收到消息后进行处理。下面实现中介者： ```javascript const playDirector = (function () {   let players = {},  // 保存所有玩家     operations = {} // 中介者可以执行的操作    operations.addPlayer = function (player) {     const teamColor = player.teamColor     players[teamColor] = players[teamColor] || []      players[teamColor].push(player)   }    operations.removePlayer = function (player) {     let teamColor = player.teamColor,       teamPlayers = players[teamColor] || []          teamPlayers = teamPlayers.filter((item) => {       return item !== player     })   }    operations.changeTeam = function (player, teamColor) {     operations.removePlayer(player)     player.teamColor = teamColor      operations.addPlayer(player)   }    operations.playerDead = function (player) {     let teamColor = player.teamColor,       teamPlayers = players[teamColor] || []      let all_dead = true          this.state = 'dead'  // 修改玩家的状态      for (let i = 0, player; player = teamPlayers[i++];) {       if (player.state !== 'dead') {         all_dead = false         break       }     }      if (all_dead === true) {        for (let i = 0, player; player = teamPlayers[i++];) {         player.lose()       }        for (let color in players) {         if (color !== teamColor) {           let teamPlayers = players[color]           for (let i = 0, player; player = teamPlayers[i++];) {             player.win()           }         }       }     }   }    const receiveMessage = function () {     const message = arguments[0]     operations[message].apply(this, Array.prototype.slice.call(arguments, 1))   }    return {     receiveMessage   } })() ``` 通过添加中介者，玩家与玩家之间的耦合关系已经解除，某个玩家的操作不需要通知其它玩家，只要给中介者发送一条消息，中介者处理完消息之后再把结果反馈给其它玩家。 <br> 测试代码： ```javascript const player1 = playerFactory('A', 'red') const player2 = playerFactory('B', 'red') const player3 = playerFactory('C', 'red') const player4 = playerFactory('D', 'red')  const player5 = playerFactory('E', 'blue') const player6 = playerFactory('F', 'blue') const player7 = playerFactory('G', 'blue') const player8 = playerFactory('H', 'blue')  player1.die() player2.die() player3.die() player4.die() ``` 得到结果： ![ result image](/result.png)  ### 总结 中介者模式是迪米特法则的一种实现，迪米特法则也叫最少知识原则，是指一个对象应该尽可能少了解其它的对象。如果对象之间耦合性太高，一个对象的变化将会影响其它对象，在中介者模式中，对象之间几乎不知道彼此的存在，它们之间通过中介者来相互影响。 <br> 中介者模式也存在一些缺点，最大的缺点是系统中会新增一个巨大的中介者对象，因为中介者对象之间交互的复杂性，全部转移到中介者对象上，所以维护好中介者也是很困难的事。中介者模式可以很方便地解耦对象之间的关系，但是对象之间的关系并不一定需要解耦，所以在写代码时需要权衡对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致了调用和维护困难，而且这些耦合会随着项目的变化还在继续增加，我们就可以考虑使用中介者模式来重构代码。"
  },
  {
    "title": "代理模式",
    "path": "/posts/design-pattern/proxy-pattern.html",
    "strippedContent": "### 定义 代理模式是为对象提供一个代用品或者占位符，以便控制对它的直接访问。当一个对象不想被外界直接访问，就可以使用代理，提供一个替身对象来控制对它的访问，替身对象对请求进行处理之后，再把请求转交给本体对象。 <br> <center> ![proxy image1](/proxy2.png) <br> 不使用代理模式 </center> <br> <center> ![proxy image2](/proxy1.png) <br> 使用代理模式 </center>  ### 类型 一般代理有两种类型，保护代理和虚拟代理。<br> **保护代理** 保护代理主要用来控制不同权限的对象对目标对象的访问，如果目标对象想过滤掉一些请求，就可以让自己的代理去处理掉。<br> **虚拟代理** 虚拟代理主要用来延时去创建对象或者执行目标对象的方法，如果执行目标对象的方法是一个开销很大的操作，虚拟代理就可以先代理目标对象的方法，延迟到真正需要它的时候再去调用。 <br> <br> 在JavaScript中实现保护代理比较困难，因为很难判断谁访问了对象，虚拟代理是一种比较常用的代理模式，所以接下来主要讲解虚拟代理的应用。  ### 应用 #### 使用代理实现图片预加载 在web开发中，图片预加载是一种常用的技术，当我们在网络环境差的情况下加载一张大图，图片会有一段空白的时间，为了提高用户体验，常见的做法是先使用一张loading占位图，然后通过异步的方式去加载图片，等图片加载好了再填充到img中。下面通过虚拟代理来实现这个功能： ```javascript const myImage = (function () {   const imgNode = document.createElement('img)   document.body.appendChild(imgNode)   return {     setSrc: function (src) {       imgNode.src = src     }   } })()  const proxyImage = (function () {   const img = new Image()   img.onload = function () {     myImage.setSrc(this.src)   }   return {     setSrc: function (src) {       myImage.setSrc('loading.gif')       this.src = src     }   } })()  proxyImage.setSrc('http://xxx.com/01.jpg') ``` **思考** <br> 为什么这么简单的功能需要使用代理模式了？<br><br> 我们引入面向对象中的一个原则----**单一职责原则**。<br> 它指的是一个对象或者函数，应该只有一个引起它变化的原因，通俗地将它只做一件事。在上述的图片预加载功能中，如果我们不引入代理，那myImage对象既要负责给img设置src，还要负责预加载图片，这样两个功能耦合在一起。如果有一天我们不需要预加载功能，就只能直接修改myImage对象，把预加载图片那部分的功能删掉，这也违反了开闭原则。引入代理模式，完美了解决了上述的问题。  #### 使用虚拟代理合并HTTP请求 在web开发中，网络请求的开销很大，假设我们要做一个文件同步的功能，当我们选中文件的时候，文件就会同步到服务器。首先在页面中创建可供点击的checkbox节点： ```html <input type=\"checkbox\" id=\"1\"/>1 <input type=\"checkbox\" id=\"2\"/>2 <input type=\"checkbox\" id=\"3\"/>3 <input type=\"checkbox\" id=\"4\"/>4 <input type=\"checkbox\" id=\"5\"/>5 <input type=\"checkbox\" id=\"6\"/>6 <input type=\"checkbox\" id=\"7\"/>7 <input type=\"checkbox\" id=\"7\"/>8 ``` 接下来，给checkbox绑定点击事件，然后同步文件到服务器: ```javascript const synchronousFile = function (id) {   console.log(`同步文件, id为${id}`) } const checkboxList = document.querySelectorAll('input') for (let i = 0, len = checkboxList.length; i < len; i++) {   const checkbox = checkboxList[i]   checkbox.onclick = function () {     if (this.checkbox === true) {       synchronousFile(this.id)     }   } } ``` 当我们一次性选了3个checkbox的时候，同时也向服务器发送了3次文件同步的请求。对于手速快的程序员，可能1秒钟可以点击4个checkbox，这样频繁的网络请求会带来很大的开销。<br> 解决方案就是通过代理synchronousFile方法，收集一段时间的请求，最后一次性发给服务器。比如等待两秒钟之后，然后把两秒钟内的需要同步的文件列表一起发送给服务器。实现代码如下： ```javascript const synchronousFile = function (id) {   console.log(`同步文件, id为${id}`) }  const proxySynchronousFile = (function () {   let cache = [], timer;   return function (id) {     if (cache.indexOf(id) > -1) {       cache.push(id)     }     if (timer) {       return     }     timers = setTimeout(function () {       synchronousFile(cache.join(','))       clearTimeout(timer)       timer = null       cache = []     }, 2000)   } })()  const checkboxList = document.querySelectorAll('input') for (let i = 0, len = checkboxList.length; i < len; i++) {   const checkbox = checkboxList[i]   checkbox.onclick = function () {     if (this.checkbox === true) {       proxySynchronousFile(this.id)     }   } }  ``` #### 缓存代理 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回结果。<br> **计算阶乘** <br> ```javascript const factorial = function (n) {   if (n === 0 || n === 1) {     return 1   }   return n * factorial(n-1) }  factorial(4)   // 24 factorial(4)  // 24 ``` 引入代理： ```javascript const proxyFactorial = (function () {   const cache = {}   return function (n) {     if (cache[n]) {       return cache[n]     }     return cache[n] = factorial.call(this, n)   } })()  proxyFactorial(4)  // 24 proxyFactorial(4)  // 24 ``` **缓存ajax请求** <br> 我们在项目中经常会遇到分页的请求，在一些场景下，同一页的数据理论上只需要去服务端获取一次，然后可以缓存起来，下次再请求同一页的时候就可以直接从缓存中获取。这种情形也可以使用缓存代理，需要注意的是从后端获取数据是一个异步操作，我们无法直接把计算结果同步的放在缓存中，而是要通过回调的方式。  ### 其它代理模式 代理模式的变体种类很多，下面做挑一些做简单的介绍。 <br> * 防火墙代理：控制网络资源的访问，保护主机不让“坏人接近”。 * 远程代理：为一个对象在不同的地址空间提供局部代表。 * 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如Vue中的对象劫持。 * 写时复制代理：通常用于复制一个庞大的的对象的情况。这种代理模式延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。  ### 总结 通过前面的这些应用我们可以看到，**代理和目标对象有一致的接口**。比如通过代理实现的预加载图片的功能，实现了setSrc方法，当我们有一天不需要图片预加载功能，也可以直接调用本体的方法，因为它们都对外提供了setSrc方法。在客户看来，代理和目标对象是一致的，客户并不知道代理和目标对象的区别。这样的做有两个好处： * 用户可以放心使用代理，因为他只关心是否能得到想要的结果 * 在任何使用本体的地方都可以替换成代理，不需要代理的时候，也可以直接使用本体 <br>  "
  },
  {
    "title": "模板方法模式",
    "path": "/posts/design-pattern/template-way-pattern.html",
    "strippedContent": "### 定义 模板方法模式是一种只需要使用继承就可以实现的设计模式，它通常由两部分组成，第一部分是抽象父类，第二部分是具体的实现子类。在抽象父类中封装了子类的算法框架，包括一些公共的方法以及子类中所有方法的执行顺序。子类通过继承父类，也继承了整个算法结构，以及重写父类中一些具体的方法。  ### Coffee和Tea 下面通过咖啡与茶的经典例子来讲解模板方法模式的具体实现。 <br> **先泡一杯咖啡** <br> 泡一杯咖啡通常包括以下步骤： 1. 把水煮沸 2. 用沸水冲泡咖啡 3. 把咖啡倒进杯子 4. 加糖和牛奶  通过代码实现上述步骤为： ```javascript class Coffee {   boilWater () {     console.log('把水煮沸')   }    brewCoffeeGriends () {     console.log('用沸水冲泡咖啡')   }    pourInCup () {     console.log('把咖啡倒进杯子里')   }    addSugarAndMilk () {     console.log('加糖和牛奶')   }    init () {     this.boilWater()     this.brewCoffeeGriends()     this.pourInCup()     this.addSugarAndMilk()   }  }  const coffee = new Coffee() coffee.init() ``` **泡一壶茶** <br> 而泡一壶茶的步骤跟泡咖啡的步骤类似： 1. 把水煮沸 2. 用沸水浸泡茶叶 3. 把茶水倒进杯子 4. 加柠檬   用代码描述如下：  ```javascript class Tea {   boilWater () {     console.log('把水煮沸')   }    steepTeaBag () {     console.log('用沸水浸泡茶叶')   }    pourInCup () {     console.log('把茶水倒进杯子里')   }    addLemon () {     console.log('加柠檬')   }    init () {     this.boilWater()     this.steepTeaBag()     this.pourInCup()     this.addLemon()   }  }  const tea = new Tea() tea.init() ``` **分离出共同点** <br> 对比泡咖啡和泡茶步骤: | 泡咖啡         |  泡茶          | |:-------------:|:-------------:| | 把水煮沸       | 把水煮沸        | | 用沸水煮咖啡    | 用沸水浸泡茶叶   | | 把咖啡倒进杯子里 | 把茶水倒进杯子里 | | 加糖和牛奶      | 加柠檬         | 分析表格我们得出泡咖啡和泡茶的不同点： - 原料不同，一个是咖啡，一个是茶，我们可以抽象为“饮料” - 泡的方式不同，咖啡是冲泡，茶是浸泡，我们可以抽象为“泡” - 加入的调料不同，一个是加糖和饮料，一个是加柠檬，我们抽象为“调料”    于是不管是泡咖啡还是泡茶，我们可以用如下代码描述： ```javascript class Beverage {   boilWater () {     console.log('把水煮沸')   }    // 空方法，由子类重写   brew () {}    // 空方法，由子类重写   pourInCup () {}    // 空方法，由子类重写   addCondiments () {}    init () {     this.boilWater()     this.brew()     this.pourInCup()     this.addCondiments()   }  } ``` 创建泡咖啡子类： ```javascript class Coffee extends Beverage {   brew () {     console.log('用沸水煮咖啡')   }    pourInCup () {     console.log('把咖啡倒进杯子里')   }    addCondiments () {     console.log('加糖和牛奶')   } }  const coffee = new Coffee() coffee.init() ``` 这样我们通过继承Beverage类，重写一些具体方法，就完成了泡咖啡子类的实现。泡茶的Tea实现类似，这里就不再具体写代码。  ### 抽象类 其实模板方法是一种严重依赖抽象类的设计模式，在Java和其它一些静态类型的语言才有，而Javascript中是没有提供抽象的支持的。在Java中有两种类，一种是抽象类，一种是具体类。具体类是用来实例化的，而抽象类不能被实例化，是用来被继承的。上面的泡咖啡和泡茶的例子中，我们抽象了饮料类，里面包含了一些空方法，如果是抽象类实现的，那这些方法可以被定义为抽象方法，继承该抽象类的子类必须实现那些抽象方法，否则编译的时候就会报错。既然JavaSript中没有抽象类，那该怎么解决了？下面提供两种变通方案： - 第一种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类中的方法，它的缺点就是带来了程序的复杂性，要求程序员主动检查接口，就需要在业务代码中加一些与业务无关的代码。 - 第二种方案是让那些空方法抛出错误，如果因为粗心忘记重写方法，就会得到错误，但是缺点是我们得到的错误时间有点太靠后，只有在程序远行时才能看到错误。  ### 应用 **架构师搭建项目** <br> 模板方法模式常被架构师用来搭建项目的框架，架构师定义好了框架的骨架，程序员继承框架的结构之后，负责往里面填写内容。比如Java中的HttpServelet技术，一个基于HttpServelet的程序包含7个生命周期，七个生命周期对应7个do方法 1. doGet 2. doHead 3. doPost 4. doPut 5. doDelete 6. doOption 7. doTrace     它还提供了一个service方法，也就是模板方法，这个方法规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServelet的子类来提供。 <br> <br> **web构建UI组件** <br> 我们知道构建一个组件的过程一般如下： 1. 初始化一个div容器 2. 通过ajax请求拉取相应的数据 3. 把数据填充到dom中，完成组件的构造 4. 通知用户组件渲染完毕     分析上述步骤，我们发现第一步和第四步一般是相同的，中间两步可能会有变化，于是我们可以把上面四步抽象到一个创建组件的父类中，父类提供第一步和第四步的实现，中间两步由具体的子类重写。     ### 钩子方法 在模板方法模式中，我们在父类中封装了子类的算法框架，这些算法框架适用大多数情况，但是也会有一些特殊情况。比如考虑泡咖啡中，可能有些顾客喝咖啡是需要加调料的，但是也有部分顾客不需要加调料，那怎么去定制这个需求，不让子类完全受父类的模板方法约束，**钩子方法**就是用来解决这个问题的。钩子是隔离变化的一种常用手段，我们一般在父类中容易变化的地方放置钩子，钩子一般会提供一个默认实现，究竟要不要完全跟父类的算法框架一样，子类可以自行决定。下面实现一个带customerWantCondiments钩子的饮料类： ```javascript class Beverage {   boilWater () {     console.log('把水煮沸')   }    // 空方法，由子类重写   brew () {     throw new Error('子类必须重写brew方法')   }    // 空方法，由子类重写   pourInCup () {     throw new Error('子类必须重写pourInCup方法')   }    // 空方法，由子类重写   addCondiments () {     throw new Error('子类必须重写addCondiments方法')   }    // 默认需要调料   customerWantCondiments () {     return true     }     init () {     this.boilWater()     this.brew()     this.pourInCup()     if (this.customerWantCondiments()) {       this.addCondiments()     }   }  } ``` 那么泡咖啡的子类可以这样实现： ```javascript class CoffeeWithHook extends Beverage {   brew () {     console.log('用沸水煮咖啡')   }    pourInCup () {     console.log('把咖啡倒进杯子里')   }    addCondiments () {     console.log('加糖和牛奶')   }    customerWantCondiments () {     return window.confirm('请问需要调料吗？')   } }  const coffeeWithHook = new CoffeeWithHook() coffeeWithHook.init() ```  ### 好莱坞原则 在模板方法模式中，我们还学到了一个新的设计原则----著名的**好莱坞原则**。 <br> <br> 在好莱坞中，许多新人演员也找不到工作，他们一般把简历递给演艺公司后就只有回家等电话，有时候等得不耐烦的演员就会打电话给演艺公司询问情况怎么样，但得到的回答是：“不要来找我，我会打电话给你”。 <br> <br> 在设计中，这种规则就称为**好莱坞原则**。这种原则的思路是，我们允许底层组件将自己挂钩到高层组件中，而高层组件决定什么时候，以何种方式去使用这些底层组件，高层组件对待底层组件的方式就跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”。 <br> <br> 模板方法模式就是好莱坞原则的一个典型使用场景，当我们用模板方法编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类去主动调用子类的方法，子类只是提供一些具体的方法的实现。除了模板方法，以下两种场景也体现了好莱坞原则： - 发布-订阅模式  <br> 在发布订阅模式中，发布者会把消息推送给订阅者，而不需要订阅者主动去fetch。 - 回调函数 <br> 在ajax异步请求中，我们一般是不知道请求具体的返回时间，通过注册一个回调函数，当数据返回后，会主动执行回调函数，这也是好莱坞原则的一种体现。    ### 总结 模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在一个使用了模板方法的模式中，子类的方法和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里，可变的逻辑部分通过不同的子类来实现，通过增加新的子类，给系统添加新的功能，不需要改动抽象父类以及其它子类，符合开放-封闭原则。"
  },
  {
    "title": "命令模式",
    "path": "/posts/design-pattern/command-pattern.html",
    "strippedContent": "### 定义 命令模式是最简单和优雅的设计模式之一，命令模式中的“命令”指的是执行某些特定操作的指令。命令模式最常用的场景是：有时候需要向某些对象发送请求，但是不知道请求的接收者是谁，也不知道被请求的操作是什么。这时候就可以通过命令模式使得请求发送者和请求接收者能够消除彼此之间的耦合关系。  ### 一个例子--实现菜单 假设我们在实现一个菜单的功能，菜单上有很多按钮，点击不同的按钮将会执行不同的操作。因为程序复杂，所以将按钮的绘制和点击按钮具体的行为分配给不同的人员编写。对于绘制按钮的程序员来说，他完全不知道某个按钮将来要做什么，他知道点击每个按钮会做一些操作。分析应用场景之后，我们发现这个需求很适合用命令模式来设计。理由如下：点击按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是行为的接收者。但是目前不知道接收者是什么对象，也不知道接收者具体做什么操作，借助命令模式，就可以解耦按钮和行为对象之间的关系。下面看具体的代码： ```html <body>   <div class=\"menu-list\">     <button id=\"btn1\">按钮1</button>     <button id=\"btn2\">按钮2</button>     <button id=\"btn3\">按钮3</button>   </div> <body>  <script>   const btn1 = document.getElementById('btn1')   const btn2 = document.getElementById('btn2')   const btn3 = document.getElementById('btn3') </script> ``` 定义setCommand函数： ```javascript function setCommand (btn, command) {   btn.onclick = function () {     command.excute()   } } ``` 定义菜单的行为，先实现刷新菜单界面、增加子菜单和删除子菜单的功能： ```javascript const menuBar = {   refresh () {     console.log('刷新菜单')   } }  const subMenu = {   add () {     console.log('增加子菜单')   },   del () {     console.log('删除子菜单')   } } ``` 封装命令类： ```javascript function RefreshMenuBarCommand (receiver) {   this.receiver = receiver }  RefreshMenuBarCommand.prototype.excute = function () {   this.receiver.refresh() }  function AddSubMenuCommand (receiver) {   this.receiver = receiver }  AddSubMenuCommand.prototype.excute = function () {   this.receiver.add() }  function DelSubMenuCommand (receiver) {   this.receiver = receiver }  DelSubMenuCommand.prototype.excute = function () {   this.receiver.del() } ``` 最后把命令接收者传入到command对象中，并把command对象安装到button上： ```javascript const refreshMenuBarCommand = new RefreshMenuBarCommand(menuBar) const addSubMenuCommand = new AddSubMenuCommand(subMenu) const delSubMenuCommand = new DelSubMenuCommand(subMenu)  setCommand(btn1, refreshMenuBarCommand) setCommand(btn2, addSubMenuCommand) setCommand(btn3, delSubMenuCommand) ``` 这样就实现了一个简单的命令模式，从中可以看出命令模式是如何将请求的发送者和接收者解耦的。  ### JavaScript中的命令模式 在JavaScript中，函数作为一等对象，是可以作为参数四处传递的。命令模式中的运算块不一定要封装在command.excute方法中，也可以封装在普通的函数中。如果我们需要请求的”接收者”，也可以通过闭包来实现。下面通过JavaScript直接实现命令模式： ```javascript const setCommand = function (btn, command) {   btn.onclick = function () {     command.excute()   } }  const menuBar = {   refresh () {     console.log('刷新菜单')   } }  const RefreshMenuBarCommand = function (receiver) {   return {     excute: function () {       receiver.refresh()     }   } }  const refreshMenuBarCommand = new RefreshMenuBarCommand(menuBar) setCommand(btn1, refreshMenuBarCommand) ```  ### 撤销命令 命令模式的另一个作用就是可以很方便地给命令对象增加撤销操作，就像在美团上下单之后也可以取消订单。下面通过一个例子来实现撤销功能，实现一个动画，这个动画是让在页面上的小球可以移动到水平方向的某个位置。页面有一个输入框和按钮，输入框中可以输入小球移动到的水平位置，点击按钮小球将开始移动到指定的坐标，使用命令模式实现代码如下： ```html <body>   <div id=\"ball\"></div>   输入小球移动后的位置：<input id=\"pos\"/>   <button id=\"moveBtn\">开始移动</button> </body>  <script>   const ball = document.getElementById('ball')   const pos = document.getElementById('pos')   const moveBtn = document.getElementById('moveBtn')    const MoveCommand = function (receiver, pos) {     this.receiver = receiver     this.pos = pos   }    MoveCommand.prototype.excute = function () {     this.receiver.start('left', this.pos, 1000, 'strongEaseOut')   }    let moveCommand    moveBtn.onclick = function () {     const animate = new Animate(ball)     moveCommand = new MoveCommand(animate, pos.value)     moveCommand.excute()   } </script> ``` 增加取消按钮： ```html <body>   <div id=\"ball\"></div>   输入小球移动后的位置：<input id=\"pos\"/>   <button id=\"moveBtn\">开始移动</button>   <button id=\"cancelBtn\">取消</button> </body> ``` 增加撤销功能，一般是给命令对象增加一个undo的方法： ```javascript  const ball = document.getElementById('ball')   const pos = document.getElementById('pos')   const moveBtn = document.getElementById('moveBtn')   const cancelBtn = document.getElementById('cancelBtn')    const MoveCommand = function (receiver, pos) {     this.receiver = receiver     this.pos = pos     this.oldPos = null   }    MoveCommand.prototype.excute = function () {     this.receiver.start('left', this.pos, 1000, 'strongEaseOut')     // 记录小球的位置     this.oldPos = this.receiver.dom.getBoundingClientReact()[this.receiver.propertyName]   }    MoveCommand.prototype.undo = function () {     this.receiver.start('left', this.oldPos, 1000, 'strongEaseOut')   }    let moveCommand    moveBtn.onclick = function () {     const animate = new Animate(ball)     moveCommand = new MoveCommand(animate, pos.value)     moveCommand.excute()   }    cancelBtn.onclick = function () {     moveCommand.undo()   } ``` 这样就完成了撤销的功能，如果使用普通的方法来实现，可能要每次记录小球的运动轨迹，才能让它回到之前的位置。而命令模式中小球的原始位置已经在小球移动之前作为command对象的属性存起来了，所以只需要编写undo方法，在这个方法中让小球回到记录的位置就可以了。  ### 撤销和重做 上面我们实现了小球回到上一个位置的撤销功能，有时候我们要实现多次撤销，比如下棋游戏中，我们可能需要悔棋5步，这时候需要使用一个历史列表来记录之前下棋的命令，然后倒序循环来每一次执行这些命令的undo操作，直到回到我们需要的那个状态。 <br> <br> 但是在一些场景下，无法顺利地使用undo操作让对象回到上一个状态。例如在Canvas画图中，画布上有一些点，我们在这些点之间画了很多线，如果这是用命令模式来实现的，就很难实现撤销操作，因为在Canvas中，擦除一条线相对不容易实现。 <br> 这时候最好的办法就是擦除整个画布，然后把之前的命令全部重新执行一遍，我们只需要实现一个历史列表记录之前的命令。对于处理不可逆的命令，这种方式是最好的。  ### 命令队列 在现实生活中，我们出去吃饭，点菜下单后，如果订单数量过多，餐厅的厨师人手不够，就需要对订单进行排队处理。这时候命令模式把请求封装成命令对象的优点再次体现了出来，对象的生命周期几乎是永久的，除非我们主动回收它。换句话来说，命令对象的生命周期跟初始请求发生的时间无关，我们可以在任何时刻执行command对象的excute方法。 <br> <br> 拿前面的动画例子来说，我们可以把div的运动过程封装成命令对象，再把他们压入一个队列，当动画执行完，当command对象的职责完成后，然后主动通知队列，此时从队列中取出下一个命令对象，然后执行它。这样如果用户重复点击执行按钮，那么不会出现上一个动画还没执行完，下一个动画已经开始的问题，用户可以完整看到每一个动画的执行过程。  ### 宏命令 宏命令是一组命令的集合，通过执行宏命令，可以一次执行一组命令。如果在你家里有一个万能遥控器，每天回家的时候，只要按一个按钮，就可以帮我们打开电脑，打开电视，打开空调。下面实现这个宏命令： ```javascript const openComputerCommand = {   excute () {     console.log('打开电脑')   } }  const openTVCommand = {   excute () {     console.log('打开电视')   } }  const openAirCommand = {   excute () {     console.log('打开空调')   } }  const MacroCommand = function {   return {     commandList: [],     add (command) {       this.commandList.push(command)     },     excute () {       for (let i = 0, len = this.commandList.length; i < len; i++) {         const command = this.commandList[i]         command.excute()       }     }   } } ``` 我们也可以为宏命令添加undo操作，跟excute方法类似，调用宏命令的undo方法就是把命令列表里的每个命令对象都执行对应的undo方法。  ### 总结 跟传统的面向对象的方式实现命令模式不同的是，在JavaScript中，可以用高阶函数和闭包来实现命令模式，这种方式更加简单。"
  },
  {
    "title": "发布-订阅模式",
    "path": "/posts/design-pattern/publisher-subscriber-pattern.html",
    "strippedContent": "### 定义 发布-订阅模式是观察者模式的一种，它定义一个对象和多个对象之间的依赖关系，当对象的状态发生改变时，所有依赖它的对象都会收到通知。在JavaScript中，我们一般使用事件模型来代替传统的发布-订阅模式。 ### DOM事件 在DOM编程中，我们经常会监听一些DOM事件，相当于订阅这个事件，然后用户触发这个事件，我们就能在回调中做一些操作。例如： ```javascript document.body.addEventListener('click', function (e) {   console.log('clicked') }, false)  document.body.click()   // 模拟用户点击 ``` 我们不知道什么时候用户会触发点击事件，我们只需要订阅它，然后等到事件触发，就能收到通知。  ### 实现发布-订阅模式 **简单的版本** ```javascript const event = {   clientList: [],   listen: function (fn) {     this.clientList.push(fn)   },   trigger: function () {     for (let i = 0, len = this.clientList.length; i < len; i++) {       const fn = this.clientList[i]       fn.apply(this, arguments)     }   } } ``` 但是这个简单的版本有一些问题，如果订阅者A和订阅B它们对发布者的感兴趣的事件不一样，但是无论发布者触发什么事件，A和B都会收到通知。所以我们添加eventChannel，对不同的订阅者进行分类： ```javascript const event = {   clientList: {},   listen: function (channel, fn) {     if (!this.clientList[channel]) {       this.clientList[channel] = []     }     this.clientList[channel].push(fn)   },   trigger: function () {     const channel = arguments[0]     const clientList = this.clientList[channel] || []     if (clientList.length === 0) {       return     }     for (let i = 0, len = clientList.length; i < len; i++) {       const fn = clientList[i]       fn.apply(this, arguments)     }   } } ``` **取消订阅** <br> 如果某个订阅者对之前订阅的channel不感兴趣了，还需要提供一个方法取消订阅。 ```javascript event.remove = function (channel, fn) {   let clientList = this.clientList[channel] || []   if (clientList.length === 0) {     return   }   if (!fn) {     clientList = []   } else {     for (let i = 0, len = clientList.length; i < len; i++) {       const _fn = clientList[i]       if (_fn === fn) {         clientList.splice(i, 1)       }     }   } } ``` ### 应用 假设我们接到一个需求，用户登录之后，需要更新网站的header头部、nav导航、购物车、消息列表等模块的用户信息。更新上面所列举的模块的前提条件就是通过ajax异步获取用户的登录信息，因为ajax是异步的，什么时候返回登录信息我们是不知道的，最常用的做法是通过回调来解决，于是有如下代码： ```javascript login.success(function(data) {   header.setAvatar(data.avatar)   nav.setAvatar(data.avatar)   message.refresh()   cart.refresh() }) ``` 上面代码的问题是，如果我负责的是登录模块，上面的其它header、nav、购物车模块是其它同事负责的，我必须还得了解其它模块的api，比如header模块的setAvatar等等，这种耦合性使程序变得僵硬。如果哪天要重构其它模块的代码，那api的名字不能随便修改，模块名也不能随意修改。如果项目又新增了一个地址模块，这个模块在用户登录之后也需要刷新，但是地址模块是其它同事负责的，那这个同事还得找到你，叫你在登录成功之后刷新地址列表。于是又增加了代码： ```javascript login.success(function(data) {   header.setAvatar(data.avatar)   nav.setAvatar(data.avatar)   message.refresh()   cart.refresh()   address.refresh() }) ``` 这种修改会让人疲倦，让开发人员失去耐心。这个时候，就需要发布-订阅模式出场，重构代码。 <br> 使用发布-订阅模式重构的思路是，在用户登录成功之后，发布一个登录成功的消息，需要刷新用户数据的模块就可以订阅这个事件，然后去调用自己的方法更新数据或者做其它的业务处理，从而解耦了登录模块和其它模块，登录模块不用关心其它模块需要做什么，也不用关心各模块的内部细节。重构的代码如下： ```javascript $.ajax('http://xxx.com?login', function (data) {   login.trigger('loginSuccess', data) }) ``` 各模块监听登录成功的消息： ```javascript const header = (function () {   login.listen('loginSuccess', function (data) {     header.setAvatar(data.avatar)   })   return {     setAvatar: function (data) {       console.log('设置header模块的头像')     }   } })() ``` 这样就算其它模块修改方法的名字或者哪一天又新增了模块需要更新用户数据，登录模块不需要关心，各个模块自己处理就行了。  ### 总结 通过上面的应用我们得出发布-订阅模式的优点，一为时间上的解耦，订阅者不需要关心什么时候发布者会发布事件；二为对象之间的解耦，上面的登录功能完美验证了这个点。发布-订阅模式应用非常广泛，既可以应用异步编程，也可以帮助我们完成更松耦合的代码编写。 <br> <br> 发布-订阅模式也不是完美的，它也有自己的缺点。首先，创建订阅者就要消耗时间和内存，当你订阅一个消息，如果这个消息始终没有发生，那这个订阅者也会一直在内存中。它虽然弱化了对象之间的联系，但如果过度使用，对象和对象之间的必要联系也会深埋在背后，导致程序难以跟踪维护和理解。特别是如果多个发布者和订阅者嵌套在一起的时候，跟踪bug也变得更加困难。"
  },
  {
    "title": "迭代器模式",
    "path": "/posts/design-pattern/iterator-pattern.html",
    "strippedContent": "### 定义 迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。在JavaScript中，例如forEach的实现就是一种迭代器模式，它可以遍历数组。jQuery中的each方法既可以遍历数组也可以遍历对象，它也是迭代器模式的一种实现。  ### 内部迭代器和外部迭代器 #### 内部迭代器 内部迭代器的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。下面实现一个简单的内部迭代器： ```javascript const each = function (array, callback) {   for (let i = 0, len = array.length; i < len; i++) {     callback(array[i], i, array[i])   } }  each([1, 2, 3], function (i, n) {   console.log(i, n) }) ``` 在JavaScript中，forEach和map函数都是内部迭代器的实现。  #### 外部迭代器 外部迭代器必须显示地请求迭代下一个元素。外部迭代器虽然增加了相对的复杂度，但是也增强了迭代器的灵活性，我们可以自己控制迭代器的过程或顺序。在ES6中，Generate函数也是外部迭代器的一种实现。下面简单实现一种外部迭代器： ```javascript const iterator = function (obj) {   let current = 0    const next = function () {     current += 1   }    const isDone = function () {     return current >= obj.length   }    const getCurrentItem = function () {     return obj[current]   }    return {     next,     isDone,     getCurrentItem,     length: obj.length   } } ``` ### 迭代数组和对象字面量 迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象，例如函数中的arguments和通过DOM API查询的NodeList。例如jQuery中的each方法就可以根据对象的类型使用不同的迭代策略： ```javascript $.each = function (obj, callback) {   let value,     i = 0,     length = obj.length,     isArray = isArraylike(obj)    if (isArray) {     for (let i = 0, len = obj.length; i < len; i++) {       value = callback(obj[i], i, obj[i])       if (value === false) {         break       }     }   } else {     for (i in obj) {       value = callback(obj[i], i, obj[i])       if (value === false) {         break       }     }   }   return obj } ```  ### 迭代器的应用 假设我们需要实现一个需求，根据不同的浏览器获取相应的上传组件对象，我们可以通过如下代码来实现： ```javascript const getUploadObj = function () {   try {     return new ActiveXObject('TXFINActiveX.FTMUpload')   } catch (e) {     if (supportFlash()) {       const obj = '<object type=\"application/x-shockwave-flash\"></object>'       return $(obj).appendTo($('body'))     } else {       const input = '<input name=\"file\" type=\"file\"/>'       return $(input).appendTo($('body'))     }   } } ``` 上面的代码，会根据不同的浏览器环境选择不同的上传方式。优先使用控件上传，控件不支持，则选择Flash上传方式，如果Flash也没安装，那就只好使用浏览器原生的表单上传。 <br> <br> 虽然上面的代码也能实现需求，但是代码里混杂着try catch块和if else语句，首先阅读困难，其次违反了开闭原则。如果我们想增加一种上传方式，比如HTML5上传，这时候唯一的办法就是继续往函数里增加条件分支。 <br> <br> 梳理下问题，我们可以看到，不管有多少种上传方式，我们都要不断去尝试每一种方式，直到找到合适的方式。于是我们可以把每种upload对象的方法封装在各自的函数里，通过迭代器获取这些upload对象，直到获取到一个可用的为止。下面通过代码来实现： ```javascript const getActiveUpload = function () {   try {     return new ActiveXObject('TXFINActiveX.FTMUpload')   } catch (e) {     return false   } }  const getFlashUpload = function () {   if (supportFlash()) {     const obj = '<object type=\"application/x-shockwave-flash\"></object>'     return $(obj).appendTo($('body'))   }   return false }  const getFormUpload = function () {   const input = '<input name=\"file\" type=\"file\"/>'   return $(input).appendTo($('body')) } ``` 上面封装的三种upload对象，如果被浏览器支持，则返回对应的upload对象，否则返回false，提示迭代器继续进行。下面来实现upload iterator： ```javascript const iteratorUpload = function () {   for (let i = 0, len = arguments.length; i < len; i++) {     const uploadObj = arguments[i]()     if (uploadObj !== false) {       return uploadObj     }   } }  const uploadObj = iteratorUpload(getActiveUpload, getFlashUpload, getFormUpload) ``` 使用迭代器重构之后，我们可以看到不同上传对象的方法被隔离在不同的函数中，互不干扰，使代码更容易维护，提高了代码的扩展性。如果我们后续还要增加其他的上传方式，只需要定义新的函数，然后再按优先级把不同的上传函数传递给iteratorUpload迭代器。"
  },
  {
    "title": "浅谈http缓存",
    "path": "/posts/http/http-stragies.html",
    "strippedContent": "### 概念 浏览器缓存是在前端开发中经常遇到的问题，它是提升页面性能同时减少服务器压力的有效手段之一。 ### 类型 #### 强缓存    请求资源时不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network中看到请求返回200的状态码，并且status code后面显示from disk cache 或者from memory cache； #### 协商缓存    向服务器发送请求，服务器会根据这个请求的request header一些参数来判断是否符合协商缓存类型，如果符合在返回304状态码并带上新的response header通知浏览器从缓存中读取资源。    >两者的共同点都是从客户端缓存中读取资源；不同点就是强缓存不会发请求，协商缓存会发送请求。  ### 缓存有关的header #### 强缓存 **Expires**：response header里的过期时间，浏览器再次加载资源时，如果在这个时间内，则会使用强缓存；  **Cache-Control**：当值设为max-age = 300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会启用强缓存。这个参数的设置和Expires作用是差不多的，只不过Expire是http1.0就有的，Cache-Control是http1.1才有的，Cache-Control的优先级高。**现在配置Expires是为了兼容不能支持http1.1的环境**。  #### 协商缓存 **Etag和If-None-Match**：Etag是上一次加载资源时，服务器返回的对该资源的唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。  **Last-Modified和If-Since-Modified**：Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。 <br> <br> 那LastModified是如何计算缓存是否过期了？前面介绍过强缓存都是通过Expires和Cache-Control中的max-age值来计算缓存失效时间，当浏览器检测到LastModified的头部时，缓存的寿命就等于header里面Date的值减去Last-Modified的值乘以10%。不同浏览器略微有不同，火狐浏览器则是在上面的基础上与一星期的时间取最小值，然后以这个值作为缓存过期时间。 > ETag和Last-Modified的作用和用法差不多。对比下他们的不同。<br>    1.在精度上，ETag要优于Last-Modified。Last-Modifed的时间单位是秒，如果某个文件在1秒内修改了很多次，那么他们的Last-Modified其实没有体现出来修改，但是ETag每次都会改变确保了精度，如果是负载均衡的服务器，各个服务器生成的Last-Modified也可能不一致。<br>    2.在性能上，ETag要逊于Last-Mdified，毕竟Last-Modified只需要记录时间，而Etag需要通过算法计算出来一个hash值。<br>    3.最后在优先级上，服务器优先考虑ETag。  ### 用户行为对浏览器缓存的控制 *  地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制； *  F5刷新，浏览器会设置max-age = 0，跳过强缓判断，会进行协商缓存判断； *  ctrl+F5，跳过强缓存和协商缓存判断，直接从服务器拉取资源。  ### 补充 补充对几个其它响应体字段的介绍。 #### Age 出现此字段，表示命中代理服务器的缓存，它的值指的是代理服务器对于请求资源的已缓存时间，单位为妙。 #### Date 指的是相应生成的时间，请求经过代理服务器时，返回的Date未必是最新的，所以通常这个时候，代理服务器增加一个Age字段告知该资源已缓存了多久。 #### Vary 对于服务器而言，资源文件可能有压缩和未压缩版本，针对不同的客户端，返回不同的资源版本。有些老式浏览器不支持解压缩，这时候需要返回未压缩版本；对于新浏览器，支持压缩的，返回压缩版本，节省带宽，提升体验。这时候用Vary来区分这个资源版本。服务器通过指定Vary：Accept-Encoding，告知代理服务器，需要缓存两个版本：压缩和未压缩。 #### s-max-age 也是cache-control的一个参数，优先级比max-age高，设置这个参数就代表使用的是公共缓存，例如通过代理服务器的缓存（比如CDN）。 #### no-cache 设置这个参数表示每次请求不是从浏览器直接获取缓存数据，而是通过向服务器发送请求，根据服务器返回的response header信息来决定是不是可以使用浏览器中缓存的数据。 #### no-store 设置这个参数表示不使用缓存。 #### 怎么控制让浏览器不缓存静态资源 有时候，很多工作场景需要避免浏览器缓存，除了浏览器浏览器隐身模式，请求时要禁用缓存： *  设置请求头：Cache-control：no-cache，no-store，must-revalidate； *  给资源加一个版本号，这样你就可以自由控制什么时候加载最新的资源: ``` <link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css?version=1.8.9\"/> ``` *  HTML禁用缓存，在页面上写: ```html <meta http-equiv=\"Cache-Control\"  content=\"no-cache, no-store, must-revalidate\"/> ``` 但是最后一种方法只有部分浏览器支持，由于代理服务器不解析HTML文档，所以也不支持这种方式。 #### IE8异常表现 上述缓存有关的规律，并非所有浏览器都遵循，比如说IE8。                  "
  }
];