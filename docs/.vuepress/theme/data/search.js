export default [
  {
    "title": "策略模式",
    "path": "/posts/design-pattern/strategy-pattern.html",
    "strippedContent": "### 定义 定义一系列算法，把它们一个个封装成策略类，具体的算法封装在策略类的内部方法里，并且使这些策略类可以互相替换。一个基于策略模式的设计至少由两部分组成，第一部分是一组策略类，每个策略类里封装了具体的算法。第二部分是环境类Context，Context主要接受客户的请求，然后把请求委托给某一个策略类。  ### 应用 下面主要通过两个具体的案例来介绍策略类的使用。 #### 使用策略模式计算奖金 很多公司都设有年终奖，而且年终奖一般跟员工的月工资基数和绩效有关。如果绩效为S，发4个月年终奖；绩效A发3个月；绩效为B，发2个月。用代码计算奖金如下： ```javascript const calculateBonus = function (performanceLevel, salary) {   if (performanceLevel === 'S') {     return salary * 4   }   if (performanceLevel === 'A') {     return salary * 3   }   if (performanceLevel === 'B') {     return salary * 2   } } ``` 用简单的代码配合if语句就能实现该功能，但是却有很多的缺点。 * calculateBonus函数庞大，有很多的if语句。 * calculateBonus缺乏弹性，如果再增加一种新的绩效等级C，或者修改其中的一种绩效的计算方式，则必须深入calculateBonus的内部实现，违法了开闭原则。 * 复用性差，如果其它地方需要重用到这些计算奖金的算法，只能通过复制和粘贴 <br>  下面使用策略模式重构代码。第一步，定义策略类： ```javascript // S class PerformanceS {   construct (salary) {     this.salary = salary   }    calculate () {     return this.salary * 4   } }  // A class PerformanceA {   construct (salary) {     this.salary = salary   }    calculate () {     return this.salary * 3   } }  // B class PerformanceB {   construct (salary) {     this.salary = salary   }    calculate () {     return this.salary * 2   } } ``` 第二步，定义环境类，Bonus： ```javascript class Bonus {   construct (salary) {     this.salary = salary   }    setStrategy (Strategy) {     this.strategy = new Strategy(this.salary)   }    getBonus () {     return this.strategy.calculate()   } } ``` 使用： ```javascript const bonus = new Bonus(7000) bonus.setStrategy(PerformanceS) bonus.getBonus() // 28000 ``` 重构完之后，我们发现代码更加清晰，每个类的职责也更加鲜明。  #### JavaScript版本的设计模式 上面我们是用面向对象的方式来实现策略模式，在JavaScript中，函数也是对象，所以更加直接的做法是： ```javascript const strategies = {   'S': function (salary) {     return salary * 4   },   'A': function (salary) {     return salary * 3   },   'B': function (salary) {     return salary * 2   } }  const calculateBonus = function (performanceLevel, salary) {   return strategies[performanceLevel](salary) } ```  #### 表单校验 策略模式中的策略类主要是用来封装算法的，但是如果只封装算法，有点大材小用。在实际开发中，我们可以把算法定义变得更广，比如一系列的业务规则，这些业务规则的目标一致，并且可以被相互替换使用。下面通过策略模式来编写一个表单校验的例子。 <br> <br> 需求是这样的，我们在编写一个注册的页面，在点击注册按钮之前，有如下几条校验规则： * 用户名长度不能为空。 * 密码长度不能少于6位。 * 手机号必须符合格式。    **第一个版本** ```javascript const registerForm = document.getElementById('registerForm')  registerForm.onsubmit = function () {   if (registerForm.userName.value === '') {     alert('用户名不能为空')     return   }   if (registerForm.password.value.length < 6) {     alert('用户密码不能少于6位')     return   }   if (!/(^1[3|5|7|8][0-9]{9}$)/.test(registerForm.phone.value)) {     alert('用户手机格式不正确')     return   } } ``` 它的缺点跟计算奖金的第一个版本差不多，缺乏弹性，违反开闭原则，复用性差。 <br> <br> **用策略模式重构** <br> 定义校验规则的策略： ```javascript const strategies= {   isNonEmpty (value, errMsg) {     if (value === '') {       return errMsg     }   },   minLength (value, length, errMsg) {     if (value.length < length) {       return errMsg     }   },   isMobile (value, errMsg) {     if (!/(^1[3|5|7|8][0-9]{9}$)/.test(value)) {       return errMsg     }   } } ``` 先看具体怎么使用Validator： ```javascript const validatorFunc = function () {   const validator = new Validator()   // 添加校验规则   validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空')   validator.add(registerForm.password, 'minLength:6', '用户密码不能少于6位')   validator.add(registerForm.mobile, 'isMobile', '用户手机格式不正确')    const errMsg = validator.start()  // 获得校验结果   return erMsg }  const registerForm = document.getElementById('registerForm') registerForm.onsubmit = function () {   const errMsg = validatorFunc()    if (errMsg) {     alert(errMsg)     return   } } ``` 定义环境类Validator类: ```javascript class Validator {   static rules = []      add (dom, rule, errMsg) {     const ary = rule.split(':')     this.rules.push(function () {       const rule = ary.shift()       ary.unshift(dom.value)       ary.push(errMsg)       return strategies[rule].apply(dom, ary)     })   }    start () {     for (let i = 0; i < this.rules.length; i++) {       const validatorFunc = this.rules[i]       const errMsg = validatorFunc()       if (errMsg) {         return errMsg       }     }   } } ``` 通过策略模式重构之后，只需要通过配置就可以完成表单的校验，这些校验规则还可以在任何地方复用。如果需要进行修改，比如改校验规则或者提示，也是成本很低的。  #### 策略模式的优缺点 **优点：** * 策略模式利用组合、委托和多态等技术和思想，避免多重if-else语句。 * 提供了对开发-关闭原则的完美支持，将算法封装在策略类中，易于修改，易于扩展。 * 由于策略模式是将算法封装在策略类中，所以这些算法可以在项目中的任何地方复用。 * 利用组合和委托让Context拥有执行算法的能力，也是继承的一种替代方案。 <br>  **缺点：** * 首先，使用策略模式会在程序中增加很多的策略类，增加了项目的代码。 * 其次，使用策略模式，必须了解所有的strategy类，这样才能知道使用哪个策略类。所以策略类必须向客户暴露它的所有实现，违反了最少知识原则。"
  },
  {
    "title": "浅谈http缓存",
    "path": "/posts/http/http-stragies.html",
    "strippedContent": "### 概念 浏览器缓存是在前端开发中经常遇到的问题，它是提升页面性能同时减少服务器压力的有效手段之一。 ### 类型 #### 强缓存    请求资源时不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network中看到请求返回200的状态码，并且status code后面显示from disk cache 或者from memory cache； #### 协商缓存    向服务器发送请求，服务器会根据这个请求的request header一些参数来判断是否符合协商缓存类型，如果符合在返回304状态码并带上新的response header通知浏览器从缓存中读取资源。    >两者的共同点都是从客户端缓存中读取资源；不同点就是强缓存不会发请求，协商缓存会发送请求。  ### 缓存有关的header #### 强缓存 **Expires**：response header里的过期时间，浏览器再次加载资源时，如果在这个时间内，则会使用强缓存；  **Cache-Control**：当值设为max-age = 300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会启用强缓存。这个参数的设置和Expires作用是差不多的，只不过Expire是http1.0就有的，Cache-Control是http1.1才有的，Cache-Control的优先级高。**现在配置Expires是为了兼容不能支持http1.1的环境**。  #### 协商缓存 **Etag和If-None-Match**：Etag是上一次加载资源时，服务器返回的对该资源的唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。  **Last-Modified和If-Since-Modified**：Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。 <br> <br> 那LastModified是如何计算缓存是否过期了？前面介绍过强缓存都是通过Expires和Cache-Control中的max-age值来计算缓存失效时间，当浏览器检测到LastModified的头部时，缓存的寿命就等于header里面Date的值减去Last-Modified的值乘以10%。不同浏览器略微有不同，火狐浏览器则是在上面的基础上与一星期的时间取最小值，然后以这个值作为缓存过期时间。 > ETag和Last-Modified的作用和用法差不多。对比下他们的不同。<br>    1.在精度上，ETag要优于Last-Modified。Last-Modifed的时间单位是秒，如果某个文件在1秒内修改了很多次，那么他们的Last-Modified其实没有体现出来修改，但是ETag每次都会改变确保了精度，如果是负载均衡的服务器，各个服务器生成的Last-Modified也可能不一致。<br>    2.在性能上，ETag要逊于Last-Mdified，毕竟Last-Modified只需要记录时间，而Etag需要通过算法计算出来一个hash值。<br>    3.最后在优先级上，服务器优先考虑ETag。  ### 用户行为对浏览器缓存的控制 *  地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制； *  F5刷新，浏览器会设置max-age = 0，跳过强缓判断，会进行协商缓存判断； *  ctrl+F5，跳过强缓存和协商缓存判断，直接从服务器拉取资源。  ### 补充 补充对几个其它响应体字段的介绍。 #### Age 出现此字段，表示命中代理服务器的缓存，它的值指的是代理服务器对于请求资源的已缓存时间，单位为妙。 #### Date 指的是相应生成的时间，请求经过代理服务器时，返回的Date未必是最新的，所以通常这个时候，代理服务器增加一个Age字段告知该资源已缓存了多久。 #### Vary 对于服务器而言，资源文件可能有压缩和未压缩版本，针对不同的客户端，返回不同的资源版本。有些老式浏览器不支持解压缩，这时候需要返回未压缩版本；对于新浏览器，支持压缩的，返回压缩版本，节省带宽，提升体验。这时候用Vary来区分这个资源版本。服务器通过指定Vary：Accept-Encoding，告知代理服务器，需要缓存两个版本：压缩和未压缩。 #### s-max-age 也是cache-control的一个参数，优先级比max-age高，设置这个参数就代表使用的是公共缓存，例如通过代理服务器的缓存（比如CDN）。 #### no-cache 设置这个参数表示每次请求不是从浏览器直接获取缓存数据，而是通过向服务器发送请求，根据服务器返回的response header信息来决定是不是可以使用浏览器中缓存的数据。 #### no-store 设置这个参数表示不使用缓存。 #### 怎么控制让浏览器不缓存静态资源 有时候，很多工作场景需要避免浏览器缓存，除了浏览器浏览器隐身模式，请求时要禁用缓存： *  设置请求头：Cache-control：no-cache，no-store，must-revalidate； *  给资源加一个版本号，这样你就可以自由控制什么时候加载最新的资源: ``` <link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css?version=1.8.9\"/> ``` *  HTML禁用缓存，在页面上写: ```html <meta http-equiv=\"Cache-Control\"  content=\"no-cache, no-store, must-revalidate\"/> ``` 但是最后一种方法只有部分浏览器支持，由于代理服务器不解析HTML文档，所以也不支持这种方式。 #### IE8异常表现 上述缓存有关的规律，并非所有浏览器都遵循，比如说IE8。                  "
  }
];