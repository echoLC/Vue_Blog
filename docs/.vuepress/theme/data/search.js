export default [
  {
    "title": "发布-订阅模式",
    "path": "/posts/design-pattern/publisher-subscriber-pattern.html",
    "strippedContent": "### 定义 发布-订阅模式是观察者模式的一种，它定义一个对象和多个对象之间的依赖关系，当对象的状态发生改变时，所有依赖它的对象都会收到通知。在JavaScript中，我们一般使用事件模型来代替传统的发布-订阅模式。 ### DOM事件 在DOM编程中，我们经常会监听一些DOM事件，相当于订阅这个事件，然后用户触发这个事件，我们就能在回调中做一些操作。例如： ```javascript document.body.addEventListener('click', function (e) {   console.log('clicked') }, false)  document.body.click()   // 模拟用户点击 ``` 我们不知道什么时候用户会触发点击事件，我们只需要订阅它，然后等到事件触发，就能收到通知。  ### 实现发布-订阅模式 **简单的版本** ```javascript const event = {   clientList: [],   listen: function (fn) {     this.clientList.push(fn)   },   trigger: function () {     for (let i = 0, len = this.clientList.length; i < len; i++) {       const fn = this.clientList[i]       fn.apply(this, arguments)     }   } } ``` 但是这个简单的版本有一些问题，如果订阅者A和订阅B它们对发布者的感兴趣的事件不一样，但是无论发布者触发什么事件，A和B都会收到通知。所以我们添加eventChannel，对不同的订阅者进行分类： ```javascript const event = {   clientList: {},   listen: function (channel, fn) {     if (!this.clientList[channel]) {       this.clientList[channel] = []     }     this.clientList[channel].push(fn)   },   trigger: function () {     const channel = arguments[0]     const clientList = this.clientList[channel] || []     if (clientList.length === 0) {       return     }     for (let i = 0, len = clientList.length; i < len; i++) {       const fn = clientList[i]       fn.apply(this, arguments)     }   } } ``` **取消订阅** <br> 如果某个订阅者对之前订阅的channel不感兴趣了，还需要提供一个方法取消订阅。 ```javascript event.remove = function (channel, fn) {   let clientList = this.clientList[channel] || []   if (clientList.length === 0) {     return   }   if (!fn) {     clientList = []   } else {     for (let i = 0, len = clientList.length; i < len; i++) {       const _fn = clientList[i]       if (_fn === fn) {         clientList.splice(i, 1)       }     }   } } ``` ### 应用 假设我们接到一个需求，用户登录之后，需要更新网站的header头部、nav导航、购物车、消息列表等模块的用户信息。更新上面所列举的模块的前提条件就是通过ajax异步获取用户的登录信息，因为ajax是异步的，什么时候返回登录信息我们是不知道的，最常用的做法是通过回调来解决，于是有如下代码： ```javascript login.success(function(data) {   header.setAvatar(data.avatar)   nav.setAvatar(data.avatar)   message.refresh()   cart.refresh() }) ``` 上面代码的问题是，如果我负责的是登录模块，上面的其它header、nav、购物车模块是其它同事负责的，我必须还得了解其它模块的api，比如header模块的setAvatar等等，这种耦合性使程序变得僵硬。如果哪天要重构其它模块的代码，那api的名字不能随便修改，模块名也不能随意修改。如果项目又新增了一个地址模块，这个模块在用户登录之后也需要刷新，但是地址模块是其它同事负责的，那这个同事还得找到你，叫你在登录成功之后刷新地址列表。于是又增加了代码： ```javascript login.success(function(data) {   header.setAvatar(data.avatar)   nav.setAvatar(data.avatar)   message.refresh()   cart.refresh()   address.refresh() }) ``` 这种修改会让人疲倦，让开发人员失去耐心。这个时候，就需要发布-订阅模式出场，重构代码。 <br> 使用发布-订阅模式重构的思路是，在用户登录成功之后，发布一个登录成功的消息，需要刷新用户数据的模块就可以订阅这个事件，然后去调用自己的方法更新数据或者做其它的业务处理，从而解耦了登录模块和其它模块，登录模块不用关心其它模块需要做什么，也不用关心各模块的内部细节。重构的代码如下： ```javascript $.ajax('http://xxx.com?login', function (data) {   login.trigger('loginSuccess', data) }) ``` 各模块监听登录成功的消息： ```javascript const header = (function () {   login.listen('loginSuccess', function (data) {     header.setAvatar(data.avatar)   })   return {     setAvatar: function (data) {       console.log('设置header模块的头像')     }   } })() ``` 这样就算其它模块修改方法的名字或者哪一天又新增了模块需要更新用户数据，登录模块不需要关心，各个模块自己处理就行了。  ### 总结 通过上面的应用我们得出发布-订阅模式的优点，一为时间上的解耦，订阅者不需要关心什么时候发布者会发布事件；二为对象之间的解耦，上面的登录功能完美验证了这个点。发布-订阅模式应用非常广泛，既可以应用异步编程，也可以帮助我们完成更松耦合的代码编写。 <br> <br> 发布-订阅模式也不是完美的，它也有自己的缺点。首先，创建订阅者就要消耗时间和内存，当你订阅一个消息，如果这个消息始终没有发生，那这个订阅者也会一直在内存中。它虽然弱化了对象之间的联系，但如果过度使用，对象和对象之间的必要联系也会深埋在背后，导致程序难以跟踪维护和理解。特别是如果多个发布者和订阅者嵌套在一起的时候，跟踪bug也变得更加困难。"
  },
  {
    "title": "迭代器模式",
    "path": "/posts/design-pattern/iterator-pattern.html",
    "strippedContent": "### 定义 迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。在JavaScript中，例如forEach的实现就是一种迭代器模式，它可以遍历数组。jQuery中的each方法既可以遍历数组也可以遍历对象，它也是迭代器模式的一种实现。  ### 内部迭代器和外部迭代器 #### 内部迭代器 内部迭代器的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。下面实现一个简单的内部迭代器： ```javascript const each = function (array, callback) {   for (let i = 0, len = array.length; i < len; i++) {     callback(array[i], i, array[i])   } }  each([1, 2, 3], function (i, n) {   console.log(i, n) }) ``` 在JavaScript中，forEach和map函数都是内部迭代器的实现。  #### 外部迭代器 外部迭代器必须显示地请求迭代下一个元素。外部迭代器虽然增加了相对的复杂度，但是也增强了迭代器的灵活性，我们可以自己控制迭代器的过程或顺序。在ES6中，Generate函数也是外部迭代器的一种实现。下面简单实现一种外部迭代器： ```javascript const iterator = function (obj) {   let current = 0    const next = function () {     current += 1   }    const isDone = function () {     return current >= obj.length   }    const getCurrentItem = function () {     return obj[current]   }    return {     next,     isDone,     getCurrentItem,     length: obj.length   } } ``` ### 迭代数组和对象字面量 迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象，例如函数中的arguments和通过DOM API查询的NodeList。例如jQuery中的each方法就可以根据对象的类型使用不同的迭代策略： ```javascript $.each = function (obj, callback) {   let value,     i = 0,     length = obj.length,     isArray = isArraylike(obj)    if (isArray) {     for (let i = 0, len = obj.length; i < len; i++) {       value = callback(obj[i], i, obj[i])       if (value === false) {         break       }     }   } else {     for (i in obj) {       value = callback(obj[i], i, obj[i])       if (value === false) {         break       }     }   }   return obj } ```  ### 迭代器的应用 假设我们需要实现一个需求，根据不同的浏览器获取相应的上传组件对象，我们可以通过如下代码来实现： ```javascript const getUploadObj = function () {   try {     return new ActiveXObject('TXFINActiveX.FTMUpload')   } catch (e) {     if (supportFlash()) {       const obj = '<object type=\"application/x-shockwave-flash\"></object>'       return $(obj).appendTo($('body'))     } else {       const input = '<input name=\"file\" type=\"file\"/>'       return $(input).appendTo($('body'))     }   } } ``` 上面的代码，会根据不同的浏览器环境选择不同的上传方式。优先使用控件上传，控件不支持，则选择Flash上传方式，如果Flash也没安装，那就只好使用浏览器原生的表单上传。 <br> <br> 虽然上面的代码也能实现需求，但是代码里混杂着try catch块和if else语句，首先阅读困难，其次违反了开闭原则。如果我们想增加一种上传方式，比如HTML5上传，这时候唯一的办法就是继续往函数里增加条件分支。 <br> <br> 梳理下问题，我们可以看到，不管有多少种上传方式，我们都要不断去尝试每一种方式，直到找到合适的方式。于是我们可以把每种upload对象的方法封装在各自的函数里，通过迭代器获取这些upload对象，直到获取到一个可用的为止。下面通过代码来实现： ```javascript const getActiveUpload = function () {   try {     return new ActiveXObject('TXFINActiveX.FTMUpload')   } catch (e) {     return false   } }  const getFlashUpload = function () {   if (supportFlash()) {     const obj = '<object type=\"application/x-shockwave-flash\"></object>'     return $(obj).appendTo($('body'))   }   return false }  const getFormUpload = function () {   const input = '<input name=\"file\" type=\"file\"/>'   return $(input).appendTo($('body')) } ``` 上面封装的三种upload对象，如果被浏览器支持，则返回对应的upload对象，否则返回false，提示迭代器继续进行。下面来实现upload iterator： ```javascript const iteratorUpload = function () {   for (let i = 0, len = arguments.length; i < len; i++) {     const uploadObj = arguments[i]()     if (uploadObj !== false) {       return uploadObj     }   } }  const uploadObj = iteratorUpload(getActiveUpload, getFlashUpload, getFormUpload) ``` 使用迭代器重构之后，我们可以看到不同上传对象的方法被隔离在不同的函数中，互不干扰，使代码更容易维护，提高了代码的扩展性。如果我们后续还要增加其他的上传方式，只需要定义新的函数，然后再按优先级把不同的上传函数传递给iteratorUpload迭代器。"
  },
  {
    "title": "代理模式",
    "path": "/posts/design-pattern/proxy-patten.html",
    "strippedContent": "### 定义 代理模式是为对象提供一个代用品或者占位符，以便控制对它的直接访问。当一个对象不想被外界直接访问，就可以使用代理，提供一个替身对象来控制对它的访问，替身对象对请求进行处理之后，再把请求转交给本体对象。 <br> <center> ![proxy image1](/proxy2.png) <br> 不使用代理模式 </center> <br> <center> ![proxy image2](/proxy1.png) <br> 使用代理模式 </center>  ### 类型 一般代理有两种类型，保护代理和虚拟代理。<br> **保护代理** 保护代理主要用来控制不同权限的对象对目标对象的访问，如果目标对象想过滤掉一些请求，就可以让自己的代理去处理掉。<br> **虚拟代理** 虚拟代理主要用来延时去创建对象或者执行目标对象的方法，如果执行目标对象的方法是一个开销很大的操作，虚拟代理就可以先代理目标对象的方法，延迟到真正需要它的时候再去调用。 <br> <br> 在JavaScript中实现保护代理比较困难，因为很难判断谁访问了对象，虚拟代理是一种比较常用的代理模式，所以接下来主要讲解虚拟代理的应用。  ### 应用 #### 使用代理实现图片预加载 在web开发中，图片预加载是一种常用的技术，当我们在网络环境差的情况下加载一张大图，图片会有一段空白的时间，为了提高用户体验，常见的做法是先使用一张loading占位图，然后通过异步的方式去加载图片，等图片加载好了再填充到img中。下面通过虚拟代理来实现这个功能： ```javascript const myImage = (function () {   const imgNode = document.createElement('img)   document.body.appendChild(imgNode)   return {     setSrc: function (src) {       imgNode.src = src     }   } })()  const proxyImage = (function () {   const img = new Image()   img.onload = function () {     myImage.setSrc(this.src)   }   return {     setSrc: function (src) {       myImage.setSrc('loading.gif')       this.src = src     }   } })()  proxyImage.setSrc('http://xxx.com/01.jpg') ``` **思考** <br> 为什么这么简单的功能需要使用代理模式了？<br><br> 我们引入面向对象中的一个原则----**单一职责原则**。<br> 它指的是一个对象或者函数，应该只有一个引起它变化的原因，通俗地将它只做一件事。在上述的图片预加载功能中，如果我们不引入代理，那myImage对象既要负责给img设置src，还要负责预加载图片，这样两个功能耦合在一起。如果有一天我们不需要预加载功能，就只能直接修改myImage对象，把预加载图片那部分的功能删掉，这也违反了开闭原则。引入代理模式，完美了解决了上述的问题。  #### 使用虚拟代理合并HTTP请求 在web开发中，网络请求的开销很大，假设我们要做一个文件同步的功能，当我们选中文件的时候，文件就会同步到服务器。首先在页面中创建可供点击的checkbox节点： ```html <input type=\"checkbox\" id=\"1\"/>1 <input type=\"checkbox\" id=\"2\"/>2 <input type=\"checkbox\" id=\"3\"/>3 <input type=\"checkbox\" id=\"4\"/>4 <input type=\"checkbox\" id=\"5\"/>5 <input type=\"checkbox\" id=\"6\"/>6 <input type=\"checkbox\" id=\"7\"/>7 <input type=\"checkbox\" id=\"7\"/>8 ``` 接下来，给checkbox绑定点击事件，然后同步文件到服务器: ```javascript const synchronousFile = function (id) {   console.log(`同步文件, id为${id}`) } const checkboxList = document.querySelectorAll('input') for (let i = 0, len = checkboxList.length; i < len; i++) {   const checkbox = checkboxList[i]   checkbox.onclick = function () {     if (this.checkbox === true) {       synchronousFile(this.id)     }   } } ``` 当我们一次性选了3个checkbox的时候，同时也向服务器发送了3次文件同步的请求。对于手速快的程序员，可能1秒钟可以点击4个checkbox，这样频繁的网络请求会带来很大的开销。<br> 解决方案就是通过代理synchronousFile方法，收集一段时间的请求，最后一次性发给服务器。比如等待两秒钟之后，然后把两秒钟内的需要同步的文件列表一起发送给服务器。实现代码如下： ```javascript const synchronousFile = function (id) {   console.log(`同步文件, id为${id}`) }  const proxySynchronousFile = (function () {   let cache = [], timer;   return function (id) {     if (cache.indexOf(id) > -1) {       cache.push(id)     }     if (timer) {       return     }     timers = setTimeout(function () {       synchronousFile(cache.join(','))       clearTimeout(timer)       timer = null       cache = []     }, 2000)   } })()  const checkboxList = document.querySelectorAll('input') for (let i = 0, len = checkboxList.length; i < len; i++) {   const checkbox = checkboxList[i]   checkbox.onclick = function () {     if (this.checkbox === true) {       proxySynchronousFile(this.id)     }   } }  ``` #### 缓存代理 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回结果。<br> **计算阶乘** <br> ```javascript const factorial = function (n) {   if (n === 0 || n === 1) {     return 1   }   return n * factorial(n-1) }  factorial(4)   // 24 factorial(4)  // 24 ``` 引入代理： ```javascript const proxyFactorial = (function () {   const cache = {}   return function (n) {     if (cache[n]) {       return cache[n]     }     return cache[n] = factorial.call(this, n)   } })()  proxyFactorial(4)  // 24 proxyFactorial(4)  // 24 ``` **缓存ajax请求** <br> 我们在项目中经常会遇到分页的请求，在一些场景下，同一页的数据理论上只需要去服务端获取一次，然后可以缓存起来，下次再请求同一页的时候就可以直接从缓存中获取。这种情形也可以使用缓存代理，需要注意的是从后端获取数据是一个异步操作，我们无法直接把计算结果同步的放在缓存中，而是要通过回调的方式。  ### 其它代理模式 代理模式的变体种类很多，下面做挑一些做简单的介绍。 <br> * 防火墙代理：控制网络资源的访问，保护主机不让“坏人接近”。 * 远程代理：为一个对象在不同的地址空间提供局部代表。 * 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如Vue中的对象劫持。 * 写时复制代理：通常用于复制一个庞大的的对象的情况。这种代理模式延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。  ### 总结 通过前面的这些应用我们可以看到，**代理和目标对象有一致的接口**。比如通过代理实现的预加载图片的功能，实现了setSrc方法，当我们有一天不需要图片预加载功能，也可以直接调用本体的方法，因为它们都对外提供了setSrc方法。在客户看来，代理和目标对象是一致的，客户并不知道代理和目标对象的区别。这样的做有两个好处： * 用户可以放心使用代理，因为他只关心是否能得到想要的结果 * 在任何使用本体的地方都可以替换成代理，不需要代理的时候，也可以直接使用本体 <br>  "
  },
  {
    "title": "策略模式",
    "path": "/posts/design-pattern/strategy-pattern.html",
    "strippedContent": "### 定义 定义一系列算法，把它们一个个封装成策略类，具体的算法封装在策略类的内部方法里，并且使这些策略类可以互相替换。一个基于策略模式的设计至少由两部分组成，第一部分是一组策略类，每个策略类里封装了具体的算法。第二部分是环境类Context，Context主要接受客户的请求，然后把请求委托给某一个策略类。  ### 应用 下面主要通过两个具体的案例来介绍策略类的使用。 #### 使用策略模式计算奖金 很多公司都设有年终奖，而且年终奖一般跟员工的月工资基数和绩效有关。如果绩效为S，发4个月年终奖；绩效A发3个月；绩效为B，发2个月。用代码计算奖金如下： ```javascript const calculateBonus = function (performanceLevel, salary) {   if (performanceLevel === 'S') {     return salary * 4   }   if (performanceLevel === 'A') {     return salary * 3   }   if (performanceLevel === 'B') {     return salary * 2   } } ``` 用简单的代码配合if语句就能实现该功能，但是却有很多的缺点。 * calculateBonus函数庞大，有很多的if语句。 * calculateBonus缺乏弹性，如果再增加一种新的绩效等级C，或者修改其中的一种绩效的计算方式，则必须深入calculateBonus的内部实现，违法了开闭原则。 * 复用性差，如果其它地方需要重用到这些计算奖金的算法，只能通过复制和粘贴 <br>  下面使用策略模式重构代码。第一步，定义策略类： ```javascript // S class PerformanceS {   construct (salary) {     this.salary = salary   }    calculate () {     return this.salary * 4   } }  // A class PerformanceA {   construct (salary) {     this.salary = salary   }    calculate () {     return this.salary * 3   } }  // B class PerformanceB {   construct (salary) {     this.salary = salary   }    calculate () {     return this.salary * 2   } } ``` 第二步，定义环境类，Bonus： ```javascript class Bonus {   construct (salary) {     this.salary = salary   }    setStrategy (Strategy) {     this.strategy = new Strategy(this.salary)   }    getBonus () {     return this.strategy.calculate()   } } ``` 使用： ```javascript const bonus = new Bonus(7000) bonus.setStrategy(PerformanceS) bonus.getBonus() // 28000 ``` 重构完之后，我们发现代码更加清晰，每个类的职责也更加鲜明。  #### JavaScript版本的设计模式 上面我们是用面向对象的方式来实现策略模式，在JavaScript中，函数也是对象，所以更加直接的做法是： ```javascript const strategies = {   'S': function (salary) {     return salary * 4   },   'A': function (salary) {     return salary * 3   },   'B': function (salary) {     return salary * 2   } }  const calculateBonus = function (performanceLevel, salary) {   return strategies[performanceLevel](salary) } ```  #### 表单校验 策略模式中的策略类主要是用来封装算法的，但是如果只封装算法，有点大材小用。在实际开发中，我们可以把算法定义变得更广，比如一系列的业务规则，这些业务规则的目标一致，并且可以被相互替换使用。下面通过策略模式来编写一个表单校验的例子。 <br> <br> 需求是这样的，我们在编写一个注册的页面，在点击注册按钮之前，有如下几条校验规则： * 用户名长度不能为空。 * 密码长度不能少于6位。 * 手机号必须符合格式。    **第一个版本** ```javascript const registerForm = document.getElementById('registerForm')  registerForm.onsubmit = function () {   if (registerForm.userName.value === '') {     alert('用户名不能为空')     return   }   if (registerForm.password.value.length < 6) {     alert('用户密码不能少于6位')     return   }   if (!/(^1[3|5|7|8][0-9]{9}$)/.test(registerForm.phone.value)) {     alert('用户手机格式不正确')     return   } } ``` 它的缺点跟计算奖金的第一个版本差不多，缺乏弹性，违反开闭原则，复用性差。 <br> <br> **用策略模式重构** <br> 定义校验规则的策略： ```javascript const strategies= {   isNonEmpty (value, errMsg) {     if (value === '') {       return errMsg     }   },   minLength (value, length, errMsg) {     if (value.length < length) {       return errMsg     }   },   isMobile (value, errMsg) {     if (!/(^1[3|5|7|8][0-9]{9}$)/.test(value)) {       return errMsg     }   } } ``` 先看具体怎么使用Validator： ```javascript const validatorFunc = function () {   const validator = new Validator()   // 添加校验规则   validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空')   validator.add(registerForm.password, 'minLength:6', '用户密码不能少于6位')   validator.add(registerForm.mobile, 'isMobile', '用户手机格式不正确')    const errMsg = validator.start()  // 获得校验结果   return erMsg }  const registerForm = document.getElementById('registerForm') registerForm.onsubmit = function () {   const errMsg = validatorFunc()    if (errMsg) {     alert(errMsg)     return   } } ``` 定义环境类Validator类: ```javascript class Validator {   static rules = []      add (dom, rule, errMsg) {     const ary = rule.split(':')     this.rules.push(function () {       const rule = ary.shift()       ary.unshift(dom.value)       ary.push(errMsg)       return strategies[rule].apply(dom, ary)     })   }    start () {     for (let i = 0; i < this.rules.length; i++) {       const validatorFunc = this.rules[i]       const errMsg = validatorFunc()       if (errMsg) {         return errMsg       }     }   } } ``` 通过策略模式重构之后，只需要通过配置就可以完成表单的校验，这些校验规则还可以在任何地方复用。如果需要进行修改，比如改校验规则或者提示，也是成本很低的。  #### 策略模式的优缺点 **优点：** * 策略模式利用组合、委托和多态等技术和思想，避免多重if-else语句。 * 提供了对开发-关闭原则的完美支持，将算法封装在策略类中，易于修改，易于扩展。 * 由于策略模式是将算法封装在策略类中，所以这些算法可以在项目中的任何地方复用。 * 利用组合和委托让Context拥有执行算法的能力，也是继承的一种替代方案。 <br>  **缺点：** * 首先，使用策略模式会在程序中增加很多的策略类，增加了项目的代码。 * 其次，使用策略模式，必须了解所有的strategy类，这样才能知道使用哪个策略类。所以策略类必须向客户暴露它的所有实现，违反了最少知识原则。"
  },
  {
    "title": "浅谈http缓存",
    "path": "/posts/http/http-stragies.html",
    "strippedContent": "### 概念 浏览器缓存是在前端开发中经常遇到的问题，它是提升页面性能同时减少服务器压力的有效手段之一。 ### 类型 #### 强缓存    请求资源时不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network中看到请求返回200的状态码，并且status code后面显示from disk cache 或者from memory cache； #### 协商缓存    向服务器发送请求，服务器会根据这个请求的request header一些参数来判断是否符合协商缓存类型，如果符合在返回304状态码并带上新的response header通知浏览器从缓存中读取资源。    >两者的共同点都是从客户端缓存中读取资源；不同点就是强缓存不会发请求，协商缓存会发送请求。  ### 缓存有关的header #### 强缓存 **Expires**：response header里的过期时间，浏览器再次加载资源时，如果在这个时间内，则会使用强缓存；  **Cache-Control**：当值设为max-age = 300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会启用强缓存。这个参数的设置和Expires作用是差不多的，只不过Expire是http1.0就有的，Cache-Control是http1.1才有的，Cache-Control的优先级高。**现在配置Expires是为了兼容不能支持http1.1的环境**。  #### 协商缓存 **Etag和If-None-Match**：Etag是上一次加载资源时，服务器返回的对该资源的唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。  **Last-Modified和If-Since-Modified**：Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。 <br> <br> 那LastModified是如何计算缓存是否过期了？前面介绍过强缓存都是通过Expires和Cache-Control中的max-age值来计算缓存失效时间，当浏览器检测到LastModified的头部时，缓存的寿命就等于header里面Date的值减去Last-Modified的值乘以10%。不同浏览器略微有不同，火狐浏览器则是在上面的基础上与一星期的时间取最小值，然后以这个值作为缓存过期时间。 > ETag和Last-Modified的作用和用法差不多。对比下他们的不同。<br>    1.在精度上，ETag要优于Last-Modified。Last-Modifed的时间单位是秒，如果某个文件在1秒内修改了很多次，那么他们的Last-Modified其实没有体现出来修改，但是ETag每次都会改变确保了精度，如果是负载均衡的服务器，各个服务器生成的Last-Modified也可能不一致。<br>    2.在性能上，ETag要逊于Last-Mdified，毕竟Last-Modified只需要记录时间，而Etag需要通过算法计算出来一个hash值。<br>    3.最后在优先级上，服务器优先考虑ETag。  ### 用户行为对浏览器缓存的控制 *  地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制； *  F5刷新，浏览器会设置max-age = 0，跳过强缓判断，会进行协商缓存判断； *  ctrl+F5，跳过强缓存和协商缓存判断，直接从服务器拉取资源。  ### 补充 补充对几个其它响应体字段的介绍。 #### Age 出现此字段，表示命中代理服务器的缓存，它的值指的是代理服务器对于请求资源的已缓存时间，单位为妙。 #### Date 指的是相应生成的时间，请求经过代理服务器时，返回的Date未必是最新的，所以通常这个时候，代理服务器增加一个Age字段告知该资源已缓存了多久。 #### Vary 对于服务器而言，资源文件可能有压缩和未压缩版本，针对不同的客户端，返回不同的资源版本。有些老式浏览器不支持解压缩，这时候需要返回未压缩版本；对于新浏览器，支持压缩的，返回压缩版本，节省带宽，提升体验。这时候用Vary来区分这个资源版本。服务器通过指定Vary：Accept-Encoding，告知代理服务器，需要缓存两个版本：压缩和未压缩。 #### s-max-age 也是cache-control的一个参数，优先级比max-age高，设置这个参数就代表使用的是公共缓存，例如通过代理服务器的缓存（比如CDN）。 #### no-cache 设置这个参数表示每次请求不是从浏览器直接获取缓存数据，而是通过向服务器发送请求，根据服务器返回的response header信息来决定是不是可以使用浏览器中缓存的数据。 #### no-store 设置这个参数表示不使用缓存。 #### 怎么控制让浏览器不缓存静态资源 有时候，很多工作场景需要避免浏览器缓存，除了浏览器浏览器隐身模式，请求时要禁用缓存： *  设置请求头：Cache-control：no-cache，no-store，must-revalidate； *  给资源加一个版本号，这样你就可以自由控制什么时候加载最新的资源: ``` <link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css?version=1.8.9\"/> ``` *  HTML禁用缓存，在页面上写: ```html <meta http-equiv=\"Cache-Control\"  content=\"no-cache, no-store, must-revalidate\"/> ``` 但是最后一种方法只有部分浏览器支持，由于代理服务器不解析HTML文档，所以也不支持这种方式。 #### IE8异常表现 上述缓存有关的规律，并非所有浏览器都遵循，比如说IE8。                  "
  }
];